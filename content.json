{"posts":[{"title":"标准式博弈","text":"标准式博弈对于$3$元组$\\Gamma=(I,S,\\pi)$，$\\Gamma$被称为标准式博弈（normal form game），如果满足以下条件： 规定$I$表示（在$\\Gamma$中）玩家集合，$I$是可列的 记$S=\\bigg{S[i]\\bigg|i \\in I\\bigg}$，规定$S[i]$表示玩家$i$（在$\\Gamma$中）的策略集合，$S$表示（在$\\Gamma$中）策略空间 记$\\pi=\\bigg{\\pi[i]\\bigg|i \\in I\\bigg}$，规定$\\pi[i]$表示玩家$i$（在$\\Gamma$中）的收益函数，$\\pi$表示（在$\\Gamma$中）收益函数组合，即有$$\\pi[i]:S \\to \\mathbb R$$ 补充说明 对于标准式博弈$\\Gamma=(I,S,\\pi)$，令$J$是$I$的某一全排序，记$S[J] = \\underset{j \\in J}\\times S[j]$，$\\pi[J] = \\underset{j \\in J}\\times \\pi[j]$，即有$$\\forall s \\in S, \\space \\piJ = \\underset{j \\in J}\\times \\pij \\in \\mathbb{R}^{|J|}$$。特别的，如果$I$本身是有序的，那么可默认$S=S[I]$和$\\pi=\\pi[I]$。 有限标准式博弈对于标准式博弈$\\Gamma=(I,S,\\pi)$，$\\Gamma$被称为有限标准式博弈（finite normal form game）或者是有限的，如果满足以下条件： $0&lt;|I|&lt;\\infty$ $\\forall i \\in I,\\space 0&lt;|S[i]|&lt;\\infty$ 扩展博弈对于标准式博弈$\\Gamma=(I,S,\\pi)$，标准式博弈$\\mathrm{H}=(I,\\Delta,u)$被称为$\\Gamma$的（混合策略）扩展博弈（extensive game），如果满足以下条件： $\\Gamma$和$\\mathrm{H}$的玩家集合都是$I$ 记$\\Delta=\\bigg{\\Delta[i]\\bigg|i \\in I\\bigg}$，规定$\\Delta[i]$表示玩家$i$（在$\\mathrm{H}$中）的策略集合，$\\Delta$表示（在$\\mathrm{H}$中）策略空间，即有$$\\Delta[i] = \\bigg{x[i]\\in\\mathbb{R}+^{|S[i]|}\\bigg|\\sum{k \\in S[i]} x[i,k]=1\\bigg}$$ 记$u=\\bigg{u[i]\\bigg|i \\in I\\bigg}$，规定$u[i]$表示玩家$i$（在$\\mathrm{H}$中）的收益函数，$u$表示（在$\\mathrm{H}$中）收益函数组合，即有$$u[i]:\\Delta \\to \\mathbb R$$；对于$s \\in S$和$x \\in \\Delta$，记$x(s)=\\displaystyle\\prod_{i \\in I}x[i,s[i]]$，则有 $$ui=\\sum_{s \\in S} x(s)\\cdot\\pii$$ 补充说明 对于标准式博弈$\\Gamma=(I,S,\\pi)$及其扩展博弈$\\mathrm{H}=(I,\\Delta,u)$，为简便起见，假定$I$是有序的。对于$\\forall i \\in I, \\forall x \\in \\Delta$，$x[i]$可被认为是$i$在$S[i]$上的频率分布策略，即可定义混合策略为线性组合$x[i] \\cdot S[i]$，而$\\Delta[i] \\subset [0{:}1]^{|S[i]|}$是$i$的所有可选的线性组合，如此可记$\\Theta[i]$作为$S[i]$的凸包，即有$$\\Theta[i] = \\bigg{\\delta\\cdot S[i]\\bigg|\\delta \\in \\Delta[i]\\bigg}=\\mathrm{co}(S[i])$$，继而有$S$的凸包$$\\Theta = \\underset{i \\in I}\\times \\Theta[i]=\\mathrm{co}(S)$$。由此可见，$\\Delta[i]$和$\\Theta[i]$是同构的，$\\Delta[i]$可以被视为在$\\mathbb{R}^{|S[i]|}$上的一个标准的单位正交基的凸包，且当$|S[i]|&lt;\\infty$时，$\\Delta[i]$是在$\\mathbb{R}^{|S[i]|}$中的一个$|S[i]|-1$维单纯形。因而，$\\Delta$和$\\Theta$是同构的，如果$\\Gamma$是有限的，那么$\\Delta = \\underset{i \\in I}\\times \\Delta[i] \\subset \\underset{i \\in I}\\times [0{:}1]^{|S[i]|}$是$\\mathbb{R}^{\\prod_{i \\in I} |S[i]|}$中的一个凸多面体。 占优策略对于标准式博弈$\\Gamma=(I,S,\\pi)$，对于$i \\in I$和$x \\in S$，记$\\mathscr{x}[-i]$是$x$去除$x[i]$后剩余的组合，可以定义下面这些概念： 称$x[i] \\in S[i]$弱占优于$y[i] \\in S[i]$，记作$x[i] \\succcurlyeq y[i]$，如果满足： $\\forall z \\in S,\\space \\pii\\ge\\pii$ $\\exists z \\in S,\\space\\pii&gt;\\pii$ 称$x[i] \\in S[i]$严格占优于$y[i] \\in S[i]$，记作$x[i] \\succ y[i]$，如果满足： $\\forall z \\in S,\\space x[i] \\ne y[i] \\implies \\pii&gt;\\pii$ 称$x[i] \\in S[i]$是$i$的弱占优策略，如果满足： $\\forall z \\in S,\\space \\forall y[i] \\in S[i],\\space x[i] \\ne y[i] \\implies x[i] \\succcurlyeq y[i]$ 称$x[i] \\in S[i]$是$i$的严格占优策略，如果满足： $\\forall z \\in S,\\space \\forall y[i] \\in S[i],\\space x[i] \\ne y[i] \\implies x[i] \\succ y[i]$ 未完待续。。。","link":"/2019/04/28/1.%E6%A0%87%E5%87%86%E5%BC%8F%E5%8D%9A%E5%BC%88/"},{"title":"Python脚本作为配置文件加载","text":"背景在使用 Python 开发时，如果要把对象 obj 当作字典使用，可以直接操作 obj.__dict__（如果有的话），具体而言： 对象操作 字典操作 查 obj.foo obj.__dict__[&quot;foo&quot;] 改 obj.foo = &quot;bar&quot; obj.__dict__[&quot;foo&quot;] = &quot;bar&quot; 删 del obj.foo del obj.__dict__[&quot;foo&quot;] 对象操作和字典（这里指的是对象的命名空间）操作并不等价，字典操作并不执行复杂的方法查找和描述符，步骤更少，一般而言更快。 而要把字典 d 视为对象操作，则要专门包装一下 123456789 class DictAsObject: def __init__(self, d): self.__dict__ = d def __repr__(self): return f&quot;{type(self).__qualname__}({self.__dict__!r})&quot;dict_as_obj = DictAsObject 也可以直接用标准库中的包装，例如 123456from argparse import Namespacedef dict_as_obj(d): ns = Namespace() ns.__dict__ = d return ns 令 ns = dict_as_obj(d)，具体而言： 对象操作 字典操作 查 ns.foo d[&quot;foo&quot;] 改 ns.foo = &quot;bar&quot; d[&quot;foo&quot;] = &quot;bar&quot; 删 del ns.foo del d[&quot;foo&quot;] 更一般地说，就是要把下列操作建立对应 对象操作 字典操作 查 __getattr__ __getitem__ 改 __setattr__ __setitem__ 删 __delattr__ __delitem__ 有些不同的是，在抛异常时，对象操作抛出 AttributeError，字典操作抛出 KeyError。 有一些第三方模块实现了上述对应关系的可相互替代，例如 https://pypi.org/project/attrdict/ https://pypi.org/search/?q=attrdict https://github.com/mewwts/addict https://github.com/sanand0/orderedattrdict 我有一个现实的需求，希望能直接以 Python 脚本作为配置文件：读取一个脚本，并以 exec 函数运行之，然后把脚本运行时的全局命名空间作为配置，如果里面用到了不存在的名字，应该自动把它设为空字典 {}。操作策略借鉴了 addict，操作如下 12345&gt;&gt;&gt; from addict import Dict&gt;&gt;&gt; mapping = Dict()&gt;&gt;&gt; mapping.a.b.c.d.e = 2&gt;&gt;&gt; mapping{'a': {'b': {'c': {'d': {'e': 2}}}}} 为此，我专门写了一个模块，来适配我的需求，造轮子并非没有意义，它能加深我的思考，并且享受 DIY 的快乐。 代码实现 TIPS 代码的最新版本在 GitHub Gist 中维护https://gist.github.com/ChenyangGao/aca220b5927d9e7d3044d6f1d31baaf6 文件名称是 dictattr.py，Python 实现代码如下： dictattr123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#!/usr/bin/env python3# coding: utf-8__author__ = &quot;ChenyangGao &lt;https://chenyanggao.github.io/&gt;&quot;__version__ = (0, 1, 1)__all__ = [&quot;AttrDict&quot;, &quot;DictAttr&quot;, &quot;Properties&quot;]import builtinsfrom pathlib import Pathfrom types import CodeTypefrom typing import MutableMapping, Optional, Unionclass AttrDict(dict): &quot;扩展的 dict 类型，它的实例的 __dict__ 属性（命名空间）就是该字典本身，因此执行 __getattr__、__setattr__、__delattr__ 操作的是该字典本身&quot; def __init__(self, *args, **kwds): super().__init__(*args, **kwds) self.__dict__ = self@MutableMapping.registerclass DictAttr: &quot;&quot;&quot;这个类型实现了 collections.abc.MutableMapping 的接口，作为其结构子类型(structural subtyping)，即鸭子类型(duck typing)，而非名义子类型(nominal subtyping)。 :param init_dict: 如果不为 None，会用于替换实例的 __dict__ 属性 :: doctest &gt;&gt;&gt; d = dict(foo={}) &gt;&gt;&gt; da = DictAttr(d) &gt;&gt;&gt; da DictAttr({'foo': {}}) &gt;&gt;&gt; da.foo DictAttr({}) &gt;&gt;&gt; da.foo.bar = 1 &gt;&gt;&gt; da DictAttr({'foo': {'bar': 1}}) &gt;&gt;&gt; d {'foo': {'bar': 1}} &gt;&gt;&gt; da.__dict__ is d True &quot;&quot;&quot; def __init__(self, init_dict: Optional[dict] = None): if init_dict is not None: self.__dict__ = init_dict def __contains__(self, key): return key in self.__dict__ def __iter__(self): return iter(self.__dict__) def __len__(self): return len(self.__dict__) def __repr__(self): return f&quot;{type(self).__qualname__}({self.__dict__!r})&quot; def __getattribute__(self, attr): &quot;如果 attr 是字符串且前后都附缀两个下划线 __，则执行原始行为。否则行为相当于 __getitem__，但在取不到值时，会再执行原始行为。可能抛出 Attribute Error 异常。&quot; if type(attr) is str and attr[:2] == attr[-2:] == &quot;__&quot;: return super().__getattribute__(attr) try: return self[attr] except KeyError: return super().__getattribute__(attr) def __getitem__(self, key): &quot;从 __dict__ 中取值，当值是 dict 类型时，会被 type(self) 对应的类包装&quot; val = self.__dict__[key] if type(val) is dict: return type(self)(val) return val def __setitem__(self, key, val): &quot;向 __dict__ 中设键值&quot; self.__dict__[key] = val def __delitem__(self, key): &quot;从 __dict__ 中删键&quot; del self.__dict__[key]class Properties(DictAttr): &quot;&quot;&quot;这个类型实现了 collections.abc.MutableMapping 的接口，作为其结构子类型(structural subtyping)，即鸭子类型(duck typing)，而非名义子类型(nominal subtyping)。 :param init_dict: 如果不为 None，会用于替换实例的 __dict__ 属性 :: doctest &gt;&gt;&gt; d = dict(foo={}) &gt;&gt;&gt; props = Properties(d) &gt;&gt;&gt; props Properties({'foo': {}}) &gt;&gt;&gt; props.foo Properties({}) &gt;&gt;&gt; props.foo.bar = 1 &gt;&gt;&gt; props Properties({'foo': {'bar': 1}}) &gt;&gt;&gt; props.bar Properties({}) &gt;&gt;&gt; props Properties({'foo': {'bar': 1}, 'bar': {}}) &gt;&gt;&gt; props.baz.bay.baz = 1 &gt;&gt;&gt; props Properties({'foo': {'bar': 1}, 'bar': {}, 'baz': {'bay': {'baz': 1}}}) &gt;&gt;&gt; d {'foo': {'bar': 1}, 'bar': {}, 'baz': {'bay': {'baz': 1}}} &gt;&gt;&gt; props.__dict__ is d True &quot;&quot;&quot; def __getitem__(self, key): &quot;从 __dict__ 中取值。首先执行基类 DictAttr 的原始行为；如果取不到值，再从 builtins.__dict__ 中取值；如果取不到，则对于非下划线前缀的字符串属性，把值设为 {}，再执行一次基类的原始行为，否则抛出 KeyError。&quot; try: return super().__getitem__(key) except KeyError: try: return builtins.__dict__[key] except KeyError: pass if type(key) is not str or key.startswith(&quot;_&quot;): raise self[key] = {} return super().__getitem__(key) def __abs__(self) -&gt; dict: &quot;创建一个 dict 副本，如果有 __all__ 字段，则筛选出所有在 __all__ 中的键，否则只筛选出键是字符串类型且非下划线前缀的键值对&quot; d = self.__dict__ if &quot;__all__&quot; in d: return { k: abs(v) if isinstance(v, Properties) else v for k, v in ((k, d[k]) for k in d[&quot;__all__&quot;] if k in d) } return { k: abs(v) if isinstance(v, Properties) else v for k, v in d.items() if type(k) is str and not k.startswith(&quot;_&quot;) } def __call__(self, source: Union[str, bytes, CodeType, Path]): &quot;&quot;&quot;执行一段 Python 代码，并更新 __dict__ 属性（命名空间） :param source: Python 代码或者代码文件的路径 :return: 返回实例本身 :: tips - 请将变量名提前注入 __dict__，否则缺失时自动设为 {} - 如果代码中有 import 命令，请确保把需要的路径加到 sys.path 中，避免找不到模块 - 属性名有前缀下划线 _，用于说明想要过滤掉 :: doctest &gt;&gt;&gt; # 构造一段 Python 代码 &gt;&gt;&gt; code = 'from math import nan as _nan, inf as _inf\\\\nz = _inf\\\\ny.z = _nan\\\\nx.y.z = y.z\\\\nfoo = sum([1,2, 3])\\\\nbar = abs(1+1j)' &gt;&gt;&gt; print(code) from math import nan as _nan, inf as _inf z = _inf y.z = _nan x.y.z = y.z foo = sum([1,2, 3]) bar = abs(1+1j) &gt;&gt;&gt; props = Properties() &gt;&gt;&gt; props Properties({}) &gt;&gt;&gt; props(code) Properties({'_nan': nan, '_inf': inf, 'z': inf, 'y': {'z': nan}, 'x': {'y': {'z': nan}}, 'foo': 6, 'bar': 1.4142135623730951}) &gt;&gt;&gt; print(abs(props)) {'z': inf, 'y': {'z': nan}, 'x': {'y': {'z': nan}}, 'foo': 6, 'bar': 1.4142135623730951} &quot;&quot;&quot; code: Union[str, bytes, CodeType] if isinstance(source, Path): code = source.open(encoding=&quot;utf_8&quot;).read() else: code = source exec(code, None, self) # type: ignore return selfif __name__ == &quot;__main__&quot;: import doctest doctest.testmod(verbose=True) 使用说明代码中有文档测试 doctest，不妨运行一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148$ python dictattr.pyTrying: d = dict(foo={})Expecting nothingokTrying: da = DictAttr(d)Expecting nothingokTrying: daExpecting: DictAttr({'foo': {}})okTrying: da.fooExpecting: DictAttr({})okTrying: da.foo.bar = 1Expecting nothingokTrying: daExpecting: DictAttr({'foo': {'bar': 1}})okTrying: dExpecting: {'foo': {'bar': 1}}okTrying: da.__dict__ is dExpecting: TrueokTrying: d = dict(foo={})Expecting nothingokTrying: props = Properties(d)Expecting nothingokTrying: propsExpecting: Properties({'foo': {}})okTrying: props.fooExpecting: Properties({})okTrying: props.foo.bar = 1Expecting nothingokTrying: propsExpecting: Properties({'foo': {'bar': 1}})okTrying: props.barExpecting: Properties({})okTrying: propsExpecting: Properties({'foo': {'bar': 1}, 'bar': {}})okTrying: props.baz.bay.baz = 1Expecting nothingokTrying: propsExpecting: Properties({'foo': {'bar': 1}, 'bar': {}, 'baz': {'bay': {'baz': 1}}})okTrying: dExpecting: {'foo': {'bar': 1}, 'bar': {}, 'baz': {'bay': {'baz': 1}}}okTrying: props.__dict__ is dExpecting: TrueokTrying: code = 'from math import nan as _nan, inf as _inf\\nz = _inf\\ny.z = _nan\\nx.y.z = y.z\\nfoo = sum([1,2, 3])\\nbar = abs(1+1j)'Expecting nothingokTrying: print(code)Expecting: from math import nan as _nan, inf as _inf z = _inf y.z = _nan x.y.z = y.z foo = sum([1,2, 3]) bar = abs(1+1j)okTrying: props = Properties()Expecting nothingokTrying: propsExpecting: Properties({})okTrying: props(code)Expecting: Properties({'_nan': nan, '_inf': inf, 'z': inf, 'y': {'z': nan}, 'x': {'y': {'z': nan}}, 'foo': 6, 'bar': 1.4142135623730951})okTrying: print(abs(props))Expecting: {'z': inf, 'y': {'z': nan}, 'x': {'y': {'z': nan}}, 'foo': 6, 'bar': 1.4142135623730951}ok14 items had no tests: __main__ __main__.AttrDict __main__.AttrDict.__init__ __main__.DictAttr.__contains__ __main__.DictAttr.__delitem__ __main__.DictAttr.__getattribute__ __main__.DictAttr.__getitem__ __main__.DictAttr.__init__ __main__.DictAttr.__iter__ __main__.DictAttr.__len__ __main__.DictAttr.__repr__ __main__.DictAttr.__setitem__ __main__.Properties.__abs__ __main__.Properties.__getitem__3 items passed all tests: 8 tests in __main__.DictAttr 12 tests in __main__.Properties 6 tests in __main__.Properties.__call__26 tests in 17 items.26 passed and 0 failed. 假设现在有个 Python 脚本 config.py 作为配置文件，内容如下 config.py123456789101112131415161718192021222324252627282930313233343536373839404142## 以下是数据库连接信息# 数据库连接函数db.connect = __import__(&quot;sqlite3&quot;).connect# 主机db.host = None# 端口db.port = None# 用户名db.username = None# 密码db.password = None# 数据库db.database = &quot;:memory:&quot;## 下面是日志的相关配置 # 日志输出的最低级别log.level=__import__(&quot;logging&quot;).INFO# 日志的输出格式log.format=&quot;[\\x1b[1m%(asctime)-15s\\x1b[0m] \\x1b[36;1m%(name)s\\x1b[0m(\\x1b[31;1m%(levelname)s\\x1b[0m) ➜ %(message)s&quot;## json 的相关配置# json 序列化函数json.serialize = __import__(&quot;json&quot;).dumps# json 反序列化函数json.deserialize = __import__(&quot;json&quot;).loads## 一些需要的 64 位浮点数常量from math import nan as _nan, inf as _infNumber.SQRT_2 = abs(1+1j)Number.EPSILON = 2.0 ** -52Number.MIN_VALUE = 2.0 ** -1074Number.MAX_VALUE = sum(2.0 ** (1023 - i) for i in range(53))Number.MAX_SAFE_INTEGER = 2.0 ** 53 - 1Number.MIN_SAFE_INTEGER = -Number.MAX_SAFE_INTEGERNumber.NaN = _nanNumber.POSITIVE_INFINITY = _infNumber.NEGATIVE_INFINITY = -_inf 可以运行下面代码进行加载 1234567&gt;&gt;&gt; from dictattr import Properties&gt;&gt;&gt; props = Properties()&gt;&gt;&gt; from pathlib import Path&gt;&gt;&gt; props(Path(&quot;config.py&quot;))Properties({'db': {'connect': &lt;built-in function connect&gt;, 'host': None, 'port': None, 'username': None, 'password': None, 'database': ':memory:'}, 'log': {'level': 20, 'format': '[\\x1b[1m%(asctime)-15s\\x1b[0m] \\x1b[36;1m%(name)s\\x1b[0m(\\x1b[31;1m%(levelname)s\\x1b[0m) ➜ %(message)s'}, 'json': {'serialize': &lt;function dumps at 0x7f29156d9c10&gt;, 'deserialize': &lt;function loads at 0x7f29156d9dc0&gt;}, '_nan': nan, '_inf': inf, 'Number': {'SQRT_2': 1.4142135623730951, 'EPSILON': 2.220446049250313e-16, 'MIN_VALUE': 5e-324, 'MAX_VALUE': 1.7976931348623157e+308, 'MAX_SAFE_INTEGER': 9007199254740991.0, 'MIN_SAFE_INTEGER': -9007199254740991.0, 'NaN': nan, 'POSITIVE_INFINITY': inf, 'NEGATIVE_INFINITY': -inf}})&gt;&gt;&gt; print(abs(props)){'db': {'connect': &lt;built-in function connect&gt;, 'host': None, 'port': None, 'username': None, 'password': None, 'database': ':memory:'}, 'log': {'level': 20, 'format': '[\\x1b[1m%(asctime)-15s\\x1b[0m] \\x1b[36;1m%(name)s\\x1b[0m(\\x1b[31;1m%(levelname)s\\x1b[0m) ➜ %(message)s'}, 'json': {'serialize': &lt;function dumps at 0x7f29156d9c10&gt;, 'deserialize': &lt;function loads at 0x7f29156d9dc0&gt;}, 'Number': {'SQRT_2': 1.4142135623730951, 'EPSILON': 2.220446049250313e-16, 'MIN_VALUE': 5e-324, 'MAX_VALUE': 1.7976931348623157e+308, 'MAX_SAFE_INTEGER': 9007199254740991.0, 'MIN_SAFE_INTEGER': -9007199254740991.0, 'NaN': nan, 'POSITIVE_INFINITY': inf, 'NEGATIVE_INFINITY': -inf}} 然后就可以根据需要取用属性了 12345678&gt;&gt;&gt; props.NumberProperties({'SQRT_2': 1.4142135623730951, 'EPSILON': 2.220446049250313e-16, 'MIN_VALUE': 5e-324, 'MAX_VALUE': 1.7976931348623157e+308, 'MAX_SAFE_INTEGER': 9007199254740991.0, 'MIN_SAFE_INTEGER': -9007199254740991.0, 'NaN': nan, 'POSITIVE_INFINITY': inf, 'NEGATIVE_INFINITY': -inf})&gt;&gt;&gt; props[&quot;Number&quot;].SQRT_21.4142135623730951&gt;&gt;&gt; props.dbProperties({'connect': &lt;built-in function connect&gt;, 'host': None, 'port': None, 'username': None, 'password': None, 'database': ':memory:'})&gt;&gt;&gt; props[&quot;json&quot;]Properties({'serialize': &lt;function dumps at 0x76829bcf70&gt;, 'deserialize': &lt;function loads at 0x76829bd480&gt;})","link":"/2022/08/27/10.Python%E8%84%9A%E6%9C%AC%E4%BD%9C%E4%B8%BA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD/"},{"title":"Python脚本设置pip索引源","text":"背景Python 包索引（Python Package Index，PyPI）是由全球 Python 开发人员社区提供的大量开源 Python 包的存储库。官方索引在 https://pypi.org，网站本身由 Python 软件基金会（Python Software Foundation，PSF）维护。你也可以在上面发布自己的项目，可参考 A Beginner’s Guide to Publishing Packages on the Python Package Index (PyPi)，How to Publish an Open-Source Python Package to PyPI。 Python 使用 pip 安装第三方包时，默认使用的官方索引源 pypi 的地址 https://pypi.python.org/pypi 在中国大陆因为墙的原因，下载缓慢。跟 ubuntu 的 apt 和 archlinux 的 Pacman 有各自国内镜像源一样，pip 也有国内索引源可用，下面罗列了一部分，进一步的，为了便于设置国内源，并受到 nodejs 的 nrm 的启发，我编写了一个脚本。 key index-url trusted-url 提供者 douban http://pypi.douban.com/simple/ pypi.douban.com 豆瓣 aliyun http://mirrors.aliyun.com/pypi/simple/ mirrors.aliyun.com 阿里云 tsinghua https://pypi.tuna.tsinghua.edu.cn/simple/ pypi.tuna.tsinghua.edu.cn 清华大学 ustc https://pypi.mirrors.ustc.edu.cn/simple/ pypi.mirrors.ustc.edu.cn 中国科学技术大学 hustunique http://pypi.hustunique.com/simple/ pypi.hustunique.com 华中理工大学 sdutlinux http://pypi.sdutlinux.org/simple/ pypi.sdutlinux.org 山东理工大学 tencent http://mirrors.cloud.tencent.com/pypi/simple/ mirrors.cloud.tencent.com 腾讯云 以豆瓣源为例，假设要安装 pandas 可执行如下命令 1pip install -i http://pypi.douban.com/simple/ --trusted-host=pypi.douban.com/simple pandas 如果写到配置文件，便可不用每次指定 -i 参数 12pip config set global.index-url http://pypi.douban.com/simple/pip config set global.trusted-host pypi.douban.com 所有的 pip 配置文件路径，可以用如下命令获取 1python -c &quot;from pip._internal.configuration import get_configuration_files;print(get_configuration_files())&quot; 代码实现 TIPS 代码的最新版本在 GitHub Gist 中维护https://gist.github.com/ChenyangGao/61d5e6eeb149a38291128fcd35befffc 文件名称是 pip_index.py，Python 实现代码如下： pip_index.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#!/usr/bin/env python3# coding: utf-8&quot;&quot;&quot;\\Tool for setting the index-url of pipReference: - https://pip.pypa.io/en/latest/- https://docs.python.org/3/installing/index.html- https://docs.python.org/3/library/ensurepip.html&quot;&quot;&quot;assert __name__ == &quot;__main__&quot;, &quot;Can only be used as __main__ module&quot;__author__ = &quot;ChenyangGao &lt;https://chenyanggao.github.io/&gt;&quot;__version__ = (0, 1)from argparse import ArgumentParser, RawTextHelpFormatterparser = ArgumentParser( description=&quot;Python pip 源配置工具&quot;, formatter_class=RawTextHelpFormatter, )subparsers = parser.add_subparsers(dest=&quot;command&quot;, help=&quot;Available commands&quot;)parser_list = subparsers.add_parser( &quot;list&quot;, formatter_class=RawTextHelpFormatter, help=&quot;罗列所有可用的源&quot;, description=&quot;&quot;&quot;罗列所有可用的源，格式形如{key}: index-url: {index_url!r} trusted-host: {trusted_host!r} comment: {comment!r}&quot;&quot;&quot;)parser_use = subparsers.add_parser( &quot;use&quot;, formatter_class=RawTextHelpFormatter, help=&quot;使用 key 指定要设置的源&quot;, description=&quot;使用 key 指定要设置的源&quot;)parser_use.add_argument( &quot;key&quot;, default=&quot;pypi&quot;, nargs=&quot;?&quot;, help=&quot;key，对应某个源，默认值 pypi&quot;)parser_use.add_argument( &quot;-k&quot;, &quot;--kind&quot;, default=&quot;user&quot;, choices=(&quot;global&quot;, &quot;user&quot;, &quot;site&quot;), help=&quot;&quot;&quot;类型，默认值 user - global Use the system-wide configuration file only - user Use the user configuration file only - site Use the current environment configuration file only&quot;&quot;&quot;,)parser_use.add_argument( &quot;-i&quot;, &quot;--isolated&quot;, action=&quot;store_true&quot;, help=&quot;Run pip in an isolated mode, ignoring environment &quot; &quot;variables and user configuration.&quot;)parser_use.add_argument( &quot;-c&quot;, &quot;--cmd-only&quot;, dest=&quot;cmd_only&quot;, action=&quot;store_true&quot;, help=&quot;并不设置配置文件，只是打印一个 pip install 命令&quot;)args = parser.parse_args()from pip._internal.configuration import Configurationfrom urllib.parse import urlsplit# TIPS: 20 == logging.INFO__import__(&quot;logging&quot;).basicConfig(level=20, format=&quot;%(message)s&quot;)INDEXES = { &quot;pypi&quot;: { &quot;index-url&quot;: &quot;https://pypi.python.org/pypi&quot;, &quot;trusted-host&quot;: &quot;pypi.python.org&quot;, &quot;comment&quot;: &quot;官方源&quot; }, &quot;douban&quot;: { &quot;index-url&quot;: &quot;http://pypi.douban.com/simple/&quot;, &quot;trusted-host&quot;: &quot;pypi.douban.com&quot;, &quot;comment&quot;: &quot;豆瓣&quot; }, &quot;aliyun&quot;: { &quot;index-url&quot;: &quot;http://mirrors.aliyun.com/pypi/simple/&quot;, &quot;trusted-host&quot;: &quot;mirrors.aliyun.com&quot;, &quot;comment&quot;: &quot;阿里云&quot; }, &quot;tsinghua&quot;: { &quot;index-url&quot;: &quot;https://pypi.tuna.tsinghua.edu.cn/simple/&quot;, &quot;trusted-host&quot;: &quot;pypi.tuna.tsinghua.edu.cn&quot;, &quot;comment&quot;: &quot;清华大学&quot; }, &quot;ustc&quot;: { &quot;index-url&quot;: &quot;https://pypi.mirrors.ustc.edu.cn/simple/&quot;, &quot;trusted-host&quot;: &quot;pypi.mirrors.ustc.edu.cn&quot;, &quot;comment&quot;: &quot;中国科学技术大学&quot; }, &quot;hustunique&quot;: { &quot;index-url&quot;: &quot;http://pypi.hustunique.com/simple/&quot;, &quot;trusted-host&quot;: &quot;pypi.hustunique.com&quot;, &quot;comment&quot;: &quot;华中理工大学&quot; }, &quot;sdutlinux&quot;: { &quot;index-url&quot;: &quot;http://pypi.sdutlinux.org/simple/&quot;, &quot;trusted-host&quot;: &quot;pypi.sdutlinux.org&quot;, &quot;comment&quot;: &quot;山东理工大学&quot; }, &quot;tencent&quot;: { &quot;index-url&quot;: &quot;http://mirrors.cloud.tencent.com/pypi/simple/&quot;, &quot;trusted-host&quot;: &quot;mirrors.cloud.tencent.com&quot;, &quot;comment&quot;: &quot;腾讯云&quot; }, }def pipi_list(): &quot;罗列所有可用的源&quot; for key, index in INDEXES.items(): print(&quot;%s: %s&quot; % (key, &quot;&quot;.join(&quot;\\n %s: %r&quot; % e for e in index.items())))def pipi_use(key=&quot;pypi&quot;, kind=&quot;user&quot;, isolated=False): &quot;&quot;&quot;使用 key 指定要设置的源 :param key: key，对应某个源，默认值 pypi :param kind: 类型，默认值 user - global Use the system-wide configuration file only - user Use the user configuration file only - site Use the current environment configuration file only :param isolated: Run pip in an isolated mode, ignoring environment variables and user configuration. &quot;&quot;&quot; # assert kind in (&quot;global&quot;, &quot;user&quot;, &quot;site&quot;) index = INDEXES[key] index_url = index[&quot;index-url&quot;] trusted_host = index.get(&quot;trusted-host&quot;) or urlsplit(index_url).netloc conf = Configuration(isolated, kind) conf.load() conf.set_value(&quot;global.index-url&quot;, index_url) conf.set_value(&quot;global.trusted-host&quot;, trusted_host) conf.save()command = args.commandif command == &quot;list&quot;: pipi_list()elif command == &quot;use&quot;: if args.cmd_only: from sys import executable index = INDEXES[args.key] index_url = index[&quot;index-url&quot;] trusted_host = index.get(&quot;trusted-host&quot;) or urlsplit(index_url).netloc print(f&quot;'{executable}' -m pip install --index-url &quot; f&quot;{index_url} --trusted-host {trusted_host} &quot;) else: pipi_use(args.key, args.kind, args.isolated)else: raise NotImplementedError(f&quot;Command {command!r} is not implemented!&quot;) 使用说明命令帮助信息如下： 123456789101112$ python pip_index.py -husage: pip_index.py [-h] {list,use} ...Python pip 源配置工具positional arguments: {list,use} Available commands list 罗列所有可用的源 use 使用 key 指定要设置的源optional arguments: -h, --help show this help message and exit 不同的系统和用户，命令输出的结果会有不同，我的环境如下： 123456$ # 我当前用的 Linux 发行版$ uname -aLinux kali 5.16.0-kali3-amd64 #1 SMP PREEMPT Debian 5.16.11-1kali1 (2022-03-03) x86_64 GNU/Linux$ # 当前的用户$ whoamikali 1. list 命令命令帮助信息如下： 1234567891011$ python pip_index.py list -husage: pip_index.py list [-h]罗列所有可用的源，格式形如{key}: index-url: {index_url!r} trusted-host: {trusted_host!r} comment: {comment!r}optional arguments: -h, --help show this help message and exit 执行如下命令示例： 123456789101112131415161718192021222324252627282930313233python pip_index.py list pypi: index-url: 'https://pypi.python.org/pypi' trusted-host: 'pypi.python.org' comment: '官方源'douban: index-url: 'http://pypi.douban.com/simple/' trusted-host: 'pypi.douban.com' comment: '豆瓣'aliyun: index-url: 'http://mirrors.aliyun.com/pypi/simple/' trusted-host: 'mirrors.aliyun.com' comment: '阿里云'tsinghua: index-url: 'https://pypi.tuna.tsinghua.edu.cn/simple/' trusted-host: 'pypi.tuna.tsinghua.edu.cn' comment: '清华大学'ustc: index-url: 'https://pypi.mirrors.ustc.edu.cn/simple/' trusted-host: 'pypi.mirrors.ustc.edu.cn' comment: '中国科学技术大学'hustunique: index-url: 'http://pypi.hustunique.com/simple/' trusted-host: 'pypi.hustunique.com' comment: '华中理工大学'sdutlinux: index-url: 'http://pypi.sdutlinux.org/simple/' trusted-host: 'pypi.sdutlinux.org' comment: '山东理工大学'tencent: index-url: 'http://mirrors.cloud.tencent.com/pypi/simple/' trusted-host: 'mirrors.cloud.tencent.com' comment: '腾讯云' 2. use 命令命令帮助信息如下： 1234567891011121314151617$ python pip_index.py use -h usage: pip_index.py use [-h] [-k {global,user,site}] [-i] [-c] [key]使用 key 指定要设置的源positional arguments: key key，对应某个源，默认值 pypioptional arguments: -h, --help show this help message and exit -k {global,user,site}, --kind {global,user,site} 类型，默认值 user - global Use the system-wide configuration file only - user Use the user configuration file only - site Use the current environment configuration file only -i, --isolated Run pip in an isolated mode, ignoring environment variables and user configuration. -c, --cmd-only 并不设置配置文件，只是打印一个 pip install 命令 执行如下命令示例： 123456789101112131415$ python pip_index.py use doubanWriting to /home/kali/.config/pip/pip.conf$ cat /home/kali/.config/pip/pip.conf[global]index-url = http://pypi.douban.com/simple/trusted-host = pypi.douban.com$ pip config list global.index-url='http://pypi.douban.com/simple/'global.trusted-host='pypi.douban.com'$ # 如果仅仅只是想要使用源，而不想修改配置文件，$ # 可以用下面的命令打印一个 pip install 命令，$ # 复制后在命令行粘贴，然后在后面添加要安装的模块$ python pip_index.py use douban -c'/home/kali/anaconda3/bin/python' -m pip install --index-url http://pypi.douban.com/simple/ --trusted-host pypi.douban.com","link":"/2022/08/30/11.Python%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AEpip%E7%B4%A2%E5%BC%95%E6%BA%90/"},{"title":"Python模块-pandas.DataFrame转Excel格式的bytes数据","text":"背景 pandas is an open source, BSD-licensed library providing high-performance, easy-to-use data structures and data analysis tools for the Python programming language. 数据分析工具包 pandas，是利用 Python 进行数据分析时，一个难以割舍的选项。它的官方文档 pandas/docs 示例非常丰富，而且它的作者 Wes McKinney 另外还写了一本书 Python for Data Analysis，截至目前已经更新到第 3 版，👆点击下载。中国国内也有热心网友做了免费的翻译分享，这是第 2 版，简书-《Python数据分析》2nd。 我曾经实现过一个单机部署的 ETL (extract, transform, load) 程序，三个步骤都基于 pandas 实现。不过这个程序最常用的功能，却仅仅是定时读取一批 SQL，然后写入 Excel，最后把这些 Excel 文件作为邮件附件进行发送，真是杀鸡用牛刀😂。 其实，我个人并不太喜欢使用 Excel 文件，先不论 Excel 那缓慢的打开速度，它的一个工作表最多也只能有 1048576（2^20） 行和 16384（2^14） 列，工作表名字最多 31 个字符。所以在我看来，CSV 才是更好的选项。 在那个 ETL 中，只允许从每个源读取一个 pandas 的 DataFrame，但在输出时，可以把多个 DataFrame 输出到一个目标里面。对于一种这类情况，即把多个 DataFrame 输出到同一个 Excel 工作簿，如果这个目标之后再作为一个源时，就不好处理了。如果这是最终的输出，而不是管道的一个中间环节，却是可以接受的。 Excel 最大的问题是工作表的规模有限，如果你的表格的规格超出 1048576×16384，也就是这个矩形不能把你数据表格完全盖住，你就得对 DataFrame 进行拆分。一般来说，我个人是不推荐做拆分的。我的建议是，一个工作簿，只开一个工作表，如果一个工作表存储不下，那就用 CSV 或者 hdf5 格式。 代码实现 TIPS 代码的最新版本在 GitHub Gist 中维护https://gist.github.com/ChenyangGao/6a3f6177ce8da748413ce304156588f9 文件名称是 pandas_to_excel_bytes.py，Python 实现代码如下： pandas_to_excel_bytes.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295#!/usr/bin/env python3# coding: utf-8&quot;&quot;&quot;这个模块提供了工具函数，可以把 `pandas` 的 `DataFrame` 转换成xlsx 格式的 Excel 文件的二进制数据&quot;&quot;&quot;__author__ = &quot;ChenyangGao &lt;https://chenyanggao.github.io/&gt;&quot;__version__ = (0, 1)__all__ = [&quot;df_to_excel_bytes&quot;, &quot;sql_to_excel_bytes&quot;]from concurrent.futures import ThreadPoolExecutorfrom contextlib import contextmanagerfrom io import BytesIO from os import PathLikefrom typing import cast, Final, Iterable, IO, TypeVar, Unionfrom types import MappingProxyType, MethodTypefrom warnings import warn# 安装 [pandas-stubs](https://pypi.org/project/pandas-stubs/) 以静态检查from pandas import read_sql, DataFrame, ExcelWriter, RangeIndexIO_T = TypeVar(&quot;IO_T&quot;, bytes, str)# Excel 的工作表名有一些非法字符 []:*?/\\\\，需要把出现的非法字符变成合法字符 _EXCEL_SHEETNAME_INVALID_CHARS_TRANSTABLE: Final[MappingProxyType] = \\ MappingProxyType(dict.fromkeys(map(ord, &quot;[]:*?/\\\\&quot;), &quot;_&quot;))# xlsx 格式的 Excel 文件，最大的行数SHEET_MAX_NROWS: Final[int] = 2 ** 20# xlsx 格式的 Excel 文件，最大的列数SHEET_MAX_NCOLS: Final[int] = 2 ** 14# xlsx 格式的 Excel 文件，工作表名最大的字符数SHEETNAME_MAX_LENGTH: Final[int] = 31def read_io(fio: IO[IO_T], /) -&gt; IO_T: &quot;从头读取一个 IO 对象的数据&quot; pos: int = fio.tell() try: fio.seek(0) return fio.read() finally: fio.seek(pos)@contextmanagerdef ctx_df_to_excel_bytes(**kwargs): &quot;&quot;&quot;上下文管理器。 把 `pandas` 的 `DataFrame` 对象转换成 xlsx 格式的 Excel 文件的字节数据 :param kwargs: 关键字参数传给 `pandas` 的 `ExcelWriter` 构造器 &gt; 请参考: pandas.io.Excel._base.ExcelWriter &gt; https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.ExcelWriter.html :return: 上下文管理器，返回一个 `pandas` 的 `ExcelWriter` 对象， 但是增加了 3 个属性： - bio: Excel 数据将被写入这个 `io.Bytes` 对象 - read: 从 `bio` 中读取 Excel 数据 - write: 把 `bio` 中的 Excel 数据写入一个路径 Example:: &gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; df = pd.DataFrame([[1,2],[3,4]]) &gt;&gt;&gt; with ctx_df_to_excel_bytes() as writer: ... for i in range(10): ... df.to_excel(writer, sheet_name=str(i), index=False) &gt;&gt;&gt; data = writer.read() &gt;&gt;&gt; df2 = pd.read_excel(data, sheet_name=&quot;5&quot;) &gt;&gt;&gt; (df == df2).all(None) True &quot;&quot;&quot; bio = kwargs[&quot;path&quot;] = BytesIO() def read(self) -&gt; bytes: return read_io(self.bio) def write(self, path: Union[bytes, int, PathLike]) -&gt; int: return open(path, &quot;wb&quot;).write(read(self)) with ExcelWriter(**kwargs) as writer: setattr(writer, &quot;bio&quot;, bio) setattr(writer, &quot;read&quot;, MethodType(read, writer)) setattr(writer, &quot;write&quot;, MethodType(write, writer)) yield writerdef df_to_excel_bytes( dfs: Union[DataFrame, dict[str, DataFrame], Iterable[DataFrame]]) -&gt; bytes: &quot;&quot;&quot;把 `pandas` 的 `DataFrame` 对象转换成 xlsx 格式的 Excel 文件的字节数据 :param dfs: 一个或一批 `pandas` 的 `DataFrame` 对象 :return: Excel 文件的字节数据 Example:: &gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; df = pd.DataFrame([[1,2],[3,4]]) &gt;&gt;&gt; data = df_to_excel_bytes([df]*10) &gt;&gt;&gt; df2 = pd.read_excel(data, sheet_name=&quot;5&quot;) &gt;&gt;&gt; (df == df2).all(None) True &quot;&quot;&quot; dfd: dict[str, DataFrame] if isinstance(dfs, DataFrame): dfd = {&quot;Sheet1&quot;: dfs} elif isinstance(dfs, dict): dfd = dfs else: dfd = {str(i): df for i, df in enumerate(dfs)} with ctx_df_to_excel_bytes() as writer: for old_k, df in dfd.items(): # 把名称 old_k 中的所有非法字符各自转换成下划线 _ k = old_k.translate(EXCEL_SHEETNAME_INVALID_CHARS_TRANSTABLE) if old_k != k: warn(f&quot;Illegal characters found in sheetname, convert {old_k!r} to {k!r}&quot;) index, columns = df.index, df.columns nrows, ncols = len(index), len(columns) index_nlevel, columns_nlevel = index.nlevels, columns.nlevels # whether_output_index 判别了是否要在 Excel 中输出 index # 只有当 index 和 columns 的 level 层数都是 1，并且 index 的开始值 start 为 0 且 # 步进 step 的值是 1，才不需要输出索引。 # TIPS: 如果 columns 的 level 层数大于 1，`pandas` 规定必须输出 index whether_output_index = not ( columns_nlevel == 1 and index_nlevel == 1 and isinstance(index, RangeIndex) and index.start == 0 and index.step == 1 ) # rng_row_step: 除去 columns 的输出后，还剩多少行可供数据输出 rng_row_step: int # rng_col_step: 除去 index 的输出后（也可能不输出），还剩多少列可供数据输出 rng_col_step: int if whether_output_index: # 如果 columns 的 level 层数大于 1，则会多输出一空白行 if columns_nlevel &gt; 1: rng_row_step = SHEET_MAX_NROWS - columns_nlevel - 1 else: rng_row_step = SHEET_MAX_NROWS - 1 rng_col_step = SHEET_MAX_NCOLS - index_nlevel else: rng_row_step = SHEET_MAX_NROWS - 1 rng_col_step = SHEET_MAX_NCOLS rng_row = range(0, nrows, rng_row_step) rng_col = range(0, ncols, rng_col_step) # suffix_template： 如果的行或列过大，导致一张工作表不能输出，则要 # 拆分成几张工作表，为此需要为同一个 DataFrame 输出的多个工作表 # 添加后缀，最后的格式形如（{name}表示引用） # {表名}^{行切分序号}_{列切分序号} # 假设某个 DataFrame 被切分成了 # sheet^0_0, sheet^0_1, sheet^1_0, sheet^1_0 # 那么数据在原来的 DataFrame 中的分布则是 # |sheet^0_0 | sheet^0_1 | # |——————————|———————————| # |sheet^1_0 | sheet^1_0 | suffix_template = &quot;&quot; # TIPS: 工作表最多只能有 31 个字符，因此如果添加后缀后，导致和表名的组合多于 # 31 字符，那么就要从表名的尾部去掉一些字符 suffix_len = 0 if len(rng_row) &gt; 1: q, r = divmod(len(rng_row), 16) l = q + (r &gt; 0) suffix_template += &quot;^{0:0%dx}&quot; % l suffix_len += l + 1 if len(rng_col) &gt; 1: q, r = divmod(len(rng_col), 16) l = q + (r &gt; 0) suffix_template += &quot;_{1:0%dx}&quot; % l suffix_len += l + 1 if suffix_len &gt; 31: raise RuntimeError(f&quot;DataFrame is too large: {old_k!r}&quot;) if suffix_len: for i, row0 in enumerate(rng_row): for j, col0 in enumerate(rng_col): suffix = suffix_template.format(i, j) key = k[:31-suffix_len] + suffix warn(f&quot;DataFrame is too large, generate sub-sheet: {key!r} (of {old_k!r})&quot;) df.iloc[row0:row0+rng_row_step, col0:col0+rng_col_step].to_excel( writer, index=whether_output_index, sheet_name=key) else: key = k[:31] if key != k: warn(f&quot;Sheetname is too long, convert {old_k!r} to {key!r}&quot;) if key == &quot;&quot;: key = &quot;Sheet1&quot; df.to_excel(writer, index=whether_output_index, sheet_name=key) return writer.read()def pandas_read_sqls( sqls: Union[str, dict[str, str], Iterable[str]], con, read_workers: int = -1,) -&gt; dict[str, DataFrame]: &quot;&quot;&quot;读取一批 SQL 查询语句，每个 SQL 的查询结果都是一个 `pandas` 的 `DataFrame` 对象。 :param sqls: 一个或一批 SQL 查询语句 :param con: SQL 查询的服务器连接 SQLAlchemy connectable, str, or sqlite3 connection Using SQLAlchemy makes it possible to use any DB supported by that library. If a DBAPI2 object, only sqlite3 is supported. The user is responsible for engine disposal and connection closure for the SQLAlchemy connectable; str connections are closed automatically. See `here &lt;https://docs.sqlalchemy.org/en/13/core/connections.html&gt;`_. :param read_workers: 并发的查询数 - 如果小于 0 或等于 1，则并发数为 1，即不并发 - 如果等于 0，则用 ThreadPoolExecutor 默认的并发数 - 如果大于 0，则数值就是并发数 :return: 返回值的内容取决于参数 `sqls`，具体为 if isinstance(sqls, str): return {&quot;&quot;: pandas.read_sql(sqls, con)} elif isinstance(sqls, dict): return {k: pandas.read_sql(sql, con) for k, sql in sqls.items()} else: return {str(i): pandas.read_sql(sql, con) for i, sql in enumerate(sqls)} &quot;&quot;&quot; if isinstance(sqls, str): return {&quot;&quot;: read_sql(sqls, con)} else: if not isinstance(sqls, dict): sqls = dict((str(i), sql) for i, sql in enumerate(sqls)) sqls = cast(dict[str, str], sqls) if read_workers &lt; 0 or read_workers == 1: return {k: read_sql(sql, con) for k, sql in sqls.items()} else: with ThreadPoolExecutor( None if read_workers == 0 else min(read_workers, len(sqls)) ) as worker: df_iter = worker.map(lambda sql: read_sql(sql, con), sqls) return {k: df for k, df in zip(sqls, df_iter)}def sql_to_excel_bytes( sqls: Union[str, dict[str, str], Iterable[str]], con, read_workers: int = -1,) -&gt; bytes: &quot;&quot;&quot;执行一些 SQL 查询语句，并把查询结果保存到同一个 xlsx 格式的 Excel 文件中， 然后读取这个 Excel 文件并返回字节数据。 :param sqls: 一个或一批 SQL 查询语句，工作表名的确定方式如下： - 如果 `sql` 是 str，则工作表名为 &quot;Sheet1&quot;，`sqls`是相应的 SQL - 如果 `sql` 是 dict， 则字典的键是工作表名，值是相应的 SQL &gt; 注意：每个工作表的名字，不允许包含这些字符之一 []:*?/\\\\ ， 如果包含，则会被自动替换成 _ - 否则 `sql` 就是可迭代对象， 则值是 SQL，序号（从0开始递增）是相应的工作表名 &gt; 注意：每个 SQL 查询返回的数据量，行数尽量 &lt;= 1048575(==2**20-1，第 1 行是表头)， 列数最好 &lt;= 16384 (==2**14)，否则会被自动拆分 :param con: SQL 查询的服务器连接 SQLAlchemy connectable, str, or sqlite3 connection Using SQLAlchemy makes it possible to use any DB supported by that library. If a DBAPI2 object, only sqlite3 is supported. The user is responsible for engine disposal and connection closure for the SQLAlchemy connectable; str connections are closed automatically. See `here &lt;https://docs.sqlalchemy.org/en/13/core/connections.html&gt;`_. :param read_workers: 并发的查询数 - 如果小于 0 或等于 1，则并发数为 1，即不并发 - 如果等于 0，则用 ThreadPoolExecutor 默认的并发数 - 如果大于 0，则数值就是并发数 :return: Excel 文件数据，bytes 形式 Example:: 可以用 sqllite3 进行测试 &gt;&gt;&gt; sql = '''\\\\ ... with recursive range(x) as ( ... values(0) ... union all ... select x + 1 from range where x &lt; POW(2, 21) ... ) ... select * from range;''' &gt;&gt;&gt; data = sql_to_excel_bytes([sql]*2, &quot;sqlite:///:memory:&quot;) ... &gt;&gt;&gt; import pandas as pd &gt;&gt;&gt; df0 = pd.read_excel(data, sheet_name=&quot;0^0&quot;) &gt;&gt;&gt; df1 = pd.read_excel(data, sheet_name=&quot;0^1&quot;) &gt;&gt;&gt; df2 = pd.read_excel(data, sheet_name=&quot;0^2&quot;) &gt;&gt;&gt; df = pd.concat([df0, df1, df2], ignore_index=True) &gt;&gt;&gt; (df.x == range(2 ** 21 + 1)).all() True &quot;&quot;&quot; dfs = pandas_read_sqls(sqls, con, read_workers) return df_to_excel_bytes(dfs)if __name__ == &quot;__main__&quot;: import doctest doctest.testmod() 扩展阅读1. 把 pandas 的 DataFrame 导出各种编码格式的字符串如果每个 pandas 的 DataFrame，各自导出到不同的目标，那么可以运用策略模式，实现一个特别简单的统一处理函数，返回导出的 bytes 或 str。 pandas_df_2_string 函数的参数和返回值类型 filetype outtype RETURN TYPE 0 'csv' bytes bytes 1 'csv' str str 2 'csv' None str 3 'excel' bytes bytes 4 'excel' None bytes 5 'feather' bytes bytes 6 'feather' None bytes 7 'hdf' bytes bytes 8 'hdf' None bytes 9 'html' bytes bytes 10 'html' str str 11 'html' None str 12 'json' bytes bytes 13 'json' str str 14 'json' None str 15 'latex' bytes bytes 16 'latex' str str 17 'latex' None str 18 'markdown' bytes bytes 19 'markdown' str str 20 'markdown' None str 21 'parquet' bytes bytes 22 'parquet' None bytes 23 'pickle' bytes bytes 24 'pickle' None bytes 25 'stata' bytes bytes 26 'stata' None bytes 27 'string' bytes bytes 28 'string' str str 29 'string' None str 30 'xml' bytes bytes 31 'xml' str str 32 'xml' None str pandas_df_2_string.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#!/usr/bin/env python3# coding: utf-8__author__ = &quot;ChenyangGao &lt;https://chenyanggao.github.io/&gt;&quot;__version__ = (0, 1)__all__ = [&quot;pandas_df_2_string&quot;]from io import BytesIO, StringIOfrom os import removefrom tempfile import mktempfrom uuid import uuid4def _to_bytes(write, /, **kwds): fio = BytesIO() write(fio, **kwds) fio.seek(0) return fio.read()def _to_str(write, /, **kwds): fio = StringIO() write(fio, **kwds) fio.seek(0) return fio.read()def _to_str_bytes(write, /, **kwds): return _to_str(write, **kwds).encode(encoding=&quot;utf-8&quot;)def _call_none(write, /, **kwds): return write(None, **kwds)def _to_hdf_bytes(write, /, **kwds): kwds.setdefault(&quot;key&quot;, &quot;default&quot;) path = mktemp(str(uuid4())) try: write(path, **kwds) return open(path, &quot;rb&quot;).read() finally: try: remove(path) except: passMAP = { &quot;csv&quot;: { bytes: _to_bytes, str: _to_str, None: _call_none, }, &quot;excel&quot;: { bytes: _to_bytes, None: _to_bytes, }, &quot;feather&quot;: { bytes: _to_bytes, None: _to_bytes, }, &quot;hdf&quot;: { bytes: _to_hdf_bytes, None: _to_hdf_bytes, }, &quot;html&quot;: { bytes: _to_str_bytes, str: _to_str, None: _call_none, }, &quot;json&quot;: { bytes: _to_bytes, str: _to_str, None: _call_none, }, &quot;latex&quot;: { bytes: _to_str_bytes, str: _to_str, None: _call_none, }, &quot;markdown&quot;: { bytes: _to_str_bytes, str: _to_str, None: _call_none, }, &quot;parquet&quot;: { bytes: _to_bytes, None: _call_none, }, &quot;pickle&quot;: { bytes: _to_bytes, None: _to_bytes, }, &quot;stata&quot;: { bytes: _to_bytes, None: _call_none, }, &quot;string&quot;: { bytes: _to_str_bytes, str: _to_str, None: _call_none, }, &quot;xml&quot;: { bytes: _to_bytes, str: _to_str, None: _call_none, },}def pandas_df_2_string(df, filetype=&quot;csv&quot;, outtype=None, **kwds): &quot;&quot;&quot;把 dataframe 导出为 bytes 或 str :param df: pandas.DataFrame 对象 :param filetype: 文件格式，可以取值如下： 'csv', 'excel', 'feather', 'hdf', 'html', 'json', 'latex', 'markdown', 'parquet', 'pickle', 'stata', 'string', 'xml' :param outtype: 输出格式，可以取值如右：bytes, str, None &gt; 注意：bytes 和 None 都是有效的，但是 str 只对某些 filetype 有效 :param kwds: 调用的方法会落实到 getattr(pandas.DataFrame, 'to_' + filetype) ，而 `kwds` 是传给这个方法的其它关键字参数 :return: 根据 outtype 的值来决定： - outtype 是 bytes，输出类型 bytes - outtype 是 str，输出类型 str - outtype 是 None，输出类型由具体 filetype 决定 &quot;&quot;&quot; submap = MAP.get(filetype) if submap is None: raise ValueError(f&quot;Invalid filetype, expected value in {MAP.keys()}, got {filetype!r}&quot;) outm = submap.get(outtype) if outm is None: raise ValueError(f&quot;Invalid outtype for filetype {filetype!r}, expected value in {submap.keys()}, got {outtype!r}&quot;) method = getattr(df, &quot;to_&quot; + filetype) return outm(method, **kwds) 2. 基于pandas实现一个简单的ETL程序我用的 Python 和 pandas 版本如下 1234$ python -VPython 3.9.12$ python -c &quot;import pandas;print(pandas.__version__)&quot;1.4.2 ETL 的 extract 这一步，需要封装所有 pandas.read_* 方法，罗列如下 12345678910import pandas as pddf = pd.DataFrame( [( &quot;pandas.&quot; + f, pd.__dict__[f].__doc__.split(&quot;\\n&quot;, 2)[1].strip() ) for f in dir(pd) if f.startswith(&quot;read_&quot;)], columns=[&quot;读入方法&quot;, &quot;说明&quot;], )print(df.to_markdown()) 读入方法 说明 0 pandas.read_clipboard Read text from clipboard and pass to read_csv. 1 pandas.read_csv Read a comma-separated values (csv) file into DataFrame. 2 pandas.read_excel Read an Excel file into a pandas DataFrame. 3 pandas.read_feather Load a feather-format object from the file path. 4 pandas.read_fwf Read a table of fixed-width formatted lines into DataFrame. 5 pandas.read_gbq Load data from Google BigQuery. 6 pandas.read_hdf Read from the store, close it if we opened it. 7 pandas.read_html Read HTML tables into a list of DataFrame objects. 8 pandas.read_json Convert a JSON string to pandas object. 9 pandas.read_orc Load an ORC object from the file path, returning a DataFrame. 10 pandas.read_parquet Load a parquet object from the file path, returning a DataFrame. 11 pandas.read_pickle Load pickled pandas object (or any object) from file. 12 pandas.read_sas Read SAS files stored as either XPORT or SAS7BDAT format files. 13 pandas.read_spss Load an SPSS file from the file path, returning a DataFrame. 14 pandas.read_sql Read SQL query or database table into a DataFrame. 15 pandas.read_sql_query Read SQL query into a DataFrame. 16 pandas.read_sql_table Read SQL database table into a DataFrame. 17 pandas.read_stata Read Stata file into DataFrame. 18 pandas.read_table Read general delimited file into DataFrame. 19 pandas.read_xml Read XML document into a DataFrame object. 而做 ETL 的 load 这一步，需要封装所有 pandas.DataFrame.to_* 方法，罗列如下 12345678910import pandas as pddf = pd.DataFrame( [( &quot;pandas.DataFrame.&quot; + f, getattr(pd.DataFrame, f).__doc__.split(&quot;\\n&quot;, 2)[1].strip() ) for f in dir(pd.DataFrame) if f.startswith(&quot;to_&quot;)], columns=[&quot;写出方法&quot;, &quot;说明&quot;], )print(df.to_markdown()) 写出方法 说明 0 pandas.DataFrame.to_clipboard Copy object to the system clipboard. 1 pandas.DataFrame.to_csv Write object to a comma-separated values (csv) file. 2 pandas.DataFrame.to_dict Convert the DataFrame to a dictionary. 3 pandas.DataFrame.to_excel Write object to an Excel sheet. 4 pandas.DataFrame.to_feather Write a DataFrame to the binary Feather format. 5 pandas.DataFrame.to_gbq Write a DataFrame to a Google BigQuery table. 6 pandas.DataFrame.to_hdf Write the contained data to an HDF5 file using HDFStore. 7 pandas.DataFrame.to_html Render a DataFrame as an HTML table. 8 pandas.DataFrame.to_json Convert the object to a JSON string. 9 pandas.DataFrame.to_latex Render object to a LaTeX tabular, longtable, or nested table/tabular. 10 pandas.DataFrame.to_markdown Print DataFrame in Markdown-friendly format. 11 pandas.DataFrame.to_numpy Convert the DataFrame to a NumPy array. 12 pandas.DataFrame.to_parquet Write a DataFrame to the binary parquet format. 13 pandas.DataFrame.to_period Convert DataFrame from DatetimeIndex to PeriodIndex. 14 pandas.DataFrame.to_pickle Pickle (serialize) object to file. 15 pandas.DataFrame.to_records Convert DataFrame to a NumPy record array. 16 pandas.DataFrame.to_sql Write records stored in a DataFrame to a SQL database. 17 pandas.DataFrame.to_stata Export DataFrame object to Stata dta format. 18 pandas.DataFrame.to_string Render a DataFrame to a console-friendly tabular output. 19 pandas.DataFrame.to_timestamp Cast to DatetimeIndex of timestamps, at beginning of period. 20 pandas.DataFrame.to_xarray Return an xarray object from the pandas object. 21 pandas.DataFrame.to_xml Render a DataFrame to an XML document. 在 ETL 的三个步骤中，最重要的是 T (transform)。我之前的项目，在 transform 这一步，专门开发了一个 DSL(Domain-specific language)，会把一种相对简单的语言翻译成 Python 和 pandas 操作。但是作为示例来说，这过于复杂了，等下次分享如何开发脚本语言时，我再展开这个例子。为了简化，我把 ETL 简化成如下这样一个上下文管理器 12345678910111213from contextlib import contextmanagerfrom typing import Any, Callablefrom pandas.core.frame import DataFrame@contextmanagerdef ctx_dataframe_as_pipe( read: Callable[[], DataFrame], write: Callable[[DataFrame], Any], ): df = read() yield df write(df) 其中 read 和 write 在调用函数时传入，请确保传入的参数类型正确，必须是两个可调用对象，如果它们各自还有其它参数，请提前用偏函数 functools.partial 进行捆绑。 未完待续","link":"/2022/09/08/13.Python%E6%A8%A1%E5%9D%97-pandas.DataFrame%E8%BD%ACExcel%E6%A0%BC%E5%BC%8F%E7%9A%84bytes%E6%95%B0%E6%8D%AE/"},{"title":"Python模块-打包多个参数于一体","text":"背景在调用 Python 函数 (See also realpython - Defining Your Own Python Function) 的时候，往往需要传入一些参数。函数所需的参数被称为形式参数 parameter，传入的参数被称为实际参数 argument (See also 5 Types of Arguments in Python Function Definitions))。 See also the FAQ question on the difference between arguments and parameters, the inspect.Parameter class, the Function definitions section, and PEP 362. 我常常需要把一些实际参数收集起来，可能后续还要进行一些更新，并在需要的时候反复使用。有一种办法是使用偏函数 functools.partial，但这需要绑定具体的函数。 123456789&gt;&gt;&gt; from functools import partial&gt;&gt;&gt; basetwo = partial(int, base=2)&gt;&gt;&gt; basetwo.__doc__ = 'Convert base 2 string to an int.'&gt;&gt;&gt; basetwo('10010')18&gt;&gt;&gt; basethree = partial(basetwo, base=3)&gt;&gt;&gt; basethree.__doc__ = 'Convert base 3 string to an int.'&gt;&gt;&gt; basethree('10010')84 于是我实现了一个类 Args，它可以一次性收集一些位置参数(positional argument，See also stackoverflow - Understanding positional arguments in Python)和关键字参数(keyword argument，See also realpython - Python args and kwargs: Demystified)，并在以后需要时，反复直接使用。 1234567&gt;&gt;&gt; from args import UpdativeArgs&gt;&gt;&gt; args = UpdativeArgs('10010', base=2)&gt;&gt;&gt; args(int)18&gt;&gt;&gt; args.update(base=3)&gt;&gt;&gt; args(int)84 Args 类更可以简化其它函数的定义，例如下面的创建数据库游标 （See PEP 249 – Python Database API Specification v2.0）的代码片段 123456789101112131415161718192021222324252627282930from args import Argsfrom contextlib import closing, contextmanager@contextmanagerdef ctx_cursor( connect, con_args, cur_args = (), do_tsac: bool = False, ): &quot;&quot;&quot;创建一个上下文管理器，返回数据库的游标对象 :param connect: 创建连接的函数，返回一个数据库连接对象 :param con_args: 创建连接对象时的参数 :param cur_args: 创建游标对象时的参数 :param do_tsac: 是否提交事务 :return: 上下文管理器，返回游标对象 &quot;&quot;&quot; with closing(Args.call(connect, con_args)) as con: with closing(Args.call(con.cursor, cur_args)) as cur: if do_tsac: try: yield cur con.commit() except BaseException: con.rollback() raise else: yield cur 示例：创建和使用一个 sqlite 游标 12345&gt;&gt;&gt; import sqlite3&gt;&gt;&gt; with ctx_cursor(... sqlite3.connect, &quot;:memory:&quot;... ) as cur: ... ... 示例：创建和使用一个 mysql 游标 123456789101112&gt;&gt;&gt; import pymysql&gt;&gt;&gt; from args import Args&gt;&gt;&gt; with ctx_cursor(... pymysql.connect,... Args(... user=&quot;root&quot;,... password=&quot;12345&quot;,... database=&quot;test&quot;,... ),... Args(pymysql.cursors.DictCursor),... ) as cur:... ... 代码实现 TIPS 代码的最新版本在 GitHub Gist 中维护https://gist.github.com/ChenyangGao/6cd16d7aa29adfc852c3f3d9a39c0b81 文件名称是 args.py，Python 实现代码如下： args.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266#!/usr/bin/env python3# coding: utf-8&quot;&quot;&quot;This module provides several classes, which are used to collect some arguments at one time and then use them repeatedly later.&quot;&quot;&quot;__author__ = &quot;ChenyangGao &lt;https://chenyanggao.github.io/&gt;&quot;__version__ = (0, 1)__all__ = [&quot;Args&quot;, &quot;UpdativeArgs&quot;]from copy import copyfrom typing import Any, Callable, Generic, TypeVarT = TypeVar(&quot;T&quot;)P = TypeVar(&quot;P&quot;, bound=tuple)K = TypeVar(&quot;K&quot;, bound=dict)class Args(Generic[T, P]): &quot;&quot;&quot;Takes some positional arguments and keyword arguments, and put them into an instance, which can be used repeatedly every next time. Fields:: self.pargs: the collected positional arguments self.kargs: the collected keyword arguments &quot;&quot;&quot; __slots__ = (&quot;pargs&quot;, &quot;kargs&quot;) def __init__(self, /, *pargs, **kargs): self.pargs: P = pargs self.kargs: K = kargs def __call__(self, /, func: Callable[..., T]) -&gt; T: &quot;&quot;&quot;Pass in the collected positional arguments and keyword arguments when calling the callable `func`.&quot;&quot;&quot; return func(*self.pargs, **self.kargs) def __copy__(self, /): return type(self)(*self.pargs, **self.kargs) def __eq__(self, other): if isinstance(other, Args): return self.pargs == other.pargs and self.kargs == other.kargs return False def __iter__(self, /): return iter((self.pargs, self.kargs)) def __repr__(self): return &quot;%s(%s)&quot; % ( type(self).__qualname__, &quot;, &quot;.join(( *map(repr, self.pargs), *(&quot;%s=%r&quot; % e for e in self.kargs.items()), )), ) @classmethod def call(cls, /, func: Callable[..., T], args: Any = ()) -&gt; T: &quot;&quot;&quot;Call the callable `func` and pass in the arguments `args`. The actual behavior as below: if isinstance(args, Args): return args(func) elif type(args) is tuple: return func(*args) elif type(args) is dict: return func(**args) return func(args) &quot;&quot;&quot; if isinstance(args, Args): return args(func) type_ = type(args) if type_ is tuple: return func(*args) elif type_ is dict: return func(**args) return func(args)class UpdativeArgs(Args): &quot;&quot;&quot;Takes some positional arguments and keyword arguments, and put them into an instance, which can be used repeatedly every next time. This derived class provides some methods to update the collected arguments. Fields:: self.pargs: the collected positional arguments self.kargs: the collected keyword arguments &quot;&quot;&quot; __slots__ = (&quot;pargs&quot;, &quot;kargs&quot;) def extend(self, /, *pargs, **kargs): &quot;&quot;&quot;Extend the collected arguments. Examples:: &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args2 = args.extend(7, 8, x=9, r=0) &gt;&gt;&gt; args2 UpdativeArgs(1, 2, 3, 7, 8, x=4, y=5, z=6, r=0) &gt;&gt;&gt; args is args2 True &quot;&quot;&quot; if pargs: self.pargs += pargs if kargs: kargs0 = self.kargs kargs0.update( (k, kargs[k]) for k in kargs.keys() - kargs0.keys() ) return self def copy_extend(self, /, *pargs, **kargs): &quot;&quot;&quot;Extend the collected arguments in a copied instance. Examples:: &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args2 = args.copy_extend(7, 8, x=9, r=0) &gt;&gt;&gt; args2 UpdativeArgs(1, 2, 3, 7, 8, x=4, y=5, z=6, r=0) &gt;&gt;&gt; args is args2 False &quot;&quot;&quot; return copy(self).extend(*pargs, **kargs) def prepend(self, /, *pargs, **kargs): &quot;&quot;&quot;Prepend the collected arguments. Examples:: &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args2 = args.prepend(7, 8, x=9, r=0) &gt;&gt;&gt; args2 UpdativeArgs(7, 8, 1, 2, 3, x=9, y=5, z=6, r=0) &gt;&gt;&gt; args is args2 True &quot;&quot;&quot; if pargs: self.pargs = pargs + self.pargs if kargs: self.kargs.update(kargs) return self def copy_prepend(self, /, *pargs, **kargs): &quot;&quot;&quot;Prepend the collected arguments in a copied instance. Examples:: &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args2 = args.copy_prepend(7, 8, x=9, r=0) &gt;&gt;&gt; args2 UpdativeArgs(7, 8, 1, 2, 3, x=9, y=5, z=6, r=0) &gt;&gt;&gt; args is args2 False &quot;&quot;&quot; return copy(self).prepend(*pargs, **kargs) def update(self, /, *pargs, **kargs): &quot;&quot;&quot;Update the collected arguments. Examples:: &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args2 = args.update(7, 8, x=9, r=0) &gt;&gt;&gt; args2 UpdativeArgs(7, 8, 3, x=9, y=5, z=6, r=0) &gt;&gt;&gt; args is args2 True &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args.update(7, 8, 10, 11, x=9, r=0) UpdativeArgs(7, 8, 10, 11, x=9, y=5, z=6, r=0) &quot;&quot;&quot; if pargs: n = len(pargs) - len(self.pargs) if n &gt;= 0: self.pargs = pargs else: self.pargs = pargs + self.pargs[n:] if kargs: self.kargs.update(kargs) return self def copy_update(self, /, *pargs, **kargs): &quot;&quot;&quot;Update the collected arguments in a copied instance. Examples:: &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args2 = args.copy_update(7, 8, x=9, r=0) &gt;&gt;&gt; args2 UpdativeArgs(7, 8, 3, x=9, y=5, z=6, r=0) &gt;&gt;&gt; args is args2 False Idempotence &gt;&gt;&gt; args3 = args2.copy_update(7, 8, x=9, r=0) &gt;&gt;&gt; args2 == args3 True Idempotence &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args2 = args.copy_update(7, 8, 10, 11, x=9, r=0) &gt;&gt;&gt; args3 = args2.copy_update(7, 8, 10, 11, x=9, r=0) &gt;&gt;&gt; args2 == args3 True &quot;&quot;&quot; return copy(self).update(*pargs, **kargs) def update_extend(self, /, *pargs, **kargs): &quot;&quot;&quot;Update and entend the collected arguments. Examples:: &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args2 = args.update_extend(7, 8, 10, 11, x=9, r=0) &gt;&gt;&gt; args2 UpdativeArgs(1, 2, 3, 11, x=4, y=5, z=6, r=0) &gt;&gt;&gt; args is args2 True &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args.update_extend(7, 8, x=9, r=0) UpdativeArgs(1, 2, 3, x=4, y=5, z=6, r=0) &quot;&quot;&quot; if pargs: n = len(self.pargs) - len(pargs) if n &lt; 0: self.pargs += pargs[n:] if kargs: kargs0 = self.kargs kargs0.update( (k, kargs[k]) for k in kargs.keys() - kargs0.keys() ) return self def copy_update_extend(self, /, *pargs, **kargs): &quot;&quot;&quot;Update and extend the collected arguments in a copied instance. Examples:: &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args2 = args.copy_update_extend(7, 8, 10, 11, x=9, r=0) &gt;&gt;&gt; args2 UpdativeArgs(1, 2, 3, 11, x=4, y=5, z=6, r=0) &gt;&gt;&gt; args is args2 False Idempotence &gt;&gt;&gt; args3 = args2.copy_update_extend(7, 8, 10, 11, x=9, r=0) &gt;&gt;&gt; args2 == args3 True Idempotence &gt;&gt;&gt; args = UpdativeArgs(1, 2, 3, x=4, y=5, z=6) &gt;&gt;&gt; args2 = args.copy_update_extend(7, 8, x=9, r=0) &gt;&gt;&gt; args2 UpdativeArgs(1, 2, 3, x=4, y=5, z=6, r=0) &gt;&gt;&gt; args3 = args2.copy_update_extend(7, 8, x=9, r=0) &gt;&gt;&gt; args2 == args3 True &quot;&quot;&quot; return copy(self).update_extend(*pargs, **kargs)if __name__ == &quot;__main__&quot;: import doctest doctest.testmod()","link":"/2022/09/01/12.Python%E6%A8%A1%E5%9D%97-%E6%89%93%E5%8C%85%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E4%BA%8E%E4%B8%80%E4%BD%93/"},{"title":"在Linux&#x2F;MacOSX上部署AList和clouddrive","text":"背景 AList 是一个开源的网盘文件罗列程序，它支持数十个网盘的挂载，并提供 WebDav 的访问方式。 clouddrive 是一个闭源的网盘文件罗列程序，虽然它只支持几个网盘，但是也有独特的功能。它也支持 WebDav。 我编写了 2 个脚本：deploy-alist.sh 可用于一键部署 AList，deploy-clouddrive.sh 可用于一键部署 clouddrive。您的设备上可能有一个应用商店，本身就提供了安装 alist 或 clouddrive，或者你使用了官方提供的一键部署脚本（但支持的平台有限），或者你用 docker 来部署，等等，这样你可能用不到我的脚本。不过如果你的平台上找不到可用的一键部署方案，不如尝试一下我的办法吧😂。 代码实现 TIPS 代码的最新版本在 GitHub Gist 中维护https://gist.github.com/ChenyangGao/e8e520de651e6375dad552b5a761902f 1. 部署 AList文件名称是 deploy-alist.sh，您可以用 bash 或 zsh 运行代码，由于用到了一些较新的语法，请确保你的解释器版本不能太低： 1bash -c &quot;$(wget -q -O - https://gist.githubusercontent.com/ChenyangGao/e8e520de651e6375dad552b5a761902f/raw/deploy-alist.sh)&quot; 2. 部署 clouddrive2文件名称是 deploy-clouddrive.sh，您可以用 bash 或 zsh 运行代码： 1bash -c &quot;$(wget -q -O - https://gist.githubusercontent.com/ChenyangGao/e8e520de651e6375dad552b5a761902f/raw/deploy-clouddrive.sh)&quot; 3. Termux 中的自启动脚本 Termux 是 Android 平台上的一个终端模拟器和开发环境，由于没有类似 systemd 之类的进程管理器，所以想要自启动需要一些其他的办法。 一种办法是使用 termux:boot，并按照文档，编写脚本并放置到 ~/.termux/boot/ 目录。虽然开机后，Termux 会启动，脚本会运行，但是如果关闭 Termux，脚本会随之关闭，即使重启 Termux，脚本也不会运行，因为这只在开机时启动一次。 我提供另一种办法，下面我提供两个脚本 alist.sh 和 clouddrive.sh，可以分别实现对 AList 和 clouddrive 的启动、停止、重启、进程状态查看、开关启动项（通过在当前 shell 的 rc 文件中写入一个启动命令来实现）。当你开了启动项，则打开 Termux 后就会开启 AList 或 clouddrive，并且会有日志文件 ~/alist.log 和 ~/clouddrive.log。 AList 的 shell 启动脚本12wget -q https://gist.githubusercontent.com/ChenyangGao/e8e520de651e6375dad552b5a761902f/raw/alist.sh -O ~/alist.shchmod +x ~/alist.sh 用法和例子如下 123456789101112131415161718192021222324$ ~/alist.sh&gt;&gt;&gt; 帮助信息start 启动 alist。可指定 -d 后台运行。————————————————————stop 停止 alist。————————————————————restart 重启 alist。可指定 -d 后台运行。————————————————————status 显示 alist 的进程信息。————————————————————log 显示 alist 的日志信息。————————————————————enable 打开终端后自动启动 alist，可指定一个 rcfile 的路径作为参数，否则自动根据默认 shell 来确定。 通过在默认 SHELL 的 rcfile 文件中写入启动命令来实现，日志在 ~/alist.log。————————————————————disable 去除 enable 注册的启动，可指定一个 rcfile 的路径作为参数，否则自动根据默认 shell 来确定。————————————————————startup 等同于 enable。————————————————————unstartup 等同于 disable。$ # 开启 alist 随 Termux 启动$ ~/alist.sh enable$ # 后台运行 alist$ ~/alist.sh start -d AList 伴随 Termux 启动由于 Termux 的包管理器可直接安装 AList，所以可以用下面的脚本实现伴随 Termux 打开后的自动启动。 1bash -c &quot;$(wget -q -O - https://gist.githubusercontent.com/ChenyangGao/e8e520de651e6375dad552b5a761902f/raw/termux-init-alist.sh)&quot; 源码如下 termux-init-alist.sh123456789101112131415161718#!/usr/bin/env bashecho &quot;Step 1: 安装 AList&quot;apt updateapt install -y alist jq wgetecho &quot;Step 2: 设置自启动&quot;wget -q https://gist.githubusercontent.com/ChenyangGao/e8e520de651e6375dad552b5a761902f/raw/alist.sh -O ~/alist.shchmod +x ~/alist.sh~/alist.sh enable~/alist.sh start -decho &quot;Step 3: 修改 admin 的密码为 123456&quot;alist admin set 123456echo &quot;Step 4: 启用 guest 用户，免密码、启用 Webdav、只读&quot;AlistToken=$(wget -q -O - --header=&quot;Content-Type: application/json&quot; --post-data='{&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;123456&quot;}' http://localhost:5244/api/auth/login | jq -r '.data.token')wget -q -O - --header=&quot;Content-Type: application/json&quot; --header &quot;Authorization: $AlistToken&quot; --post-data='{&quot;id&quot;: 2, &quot;username&quot;: &quot;guest&quot;, &quot;password&quot;: &quot;&quot;, &quot;role&quot;: 1, &quot;permission&quot;: 258, &quot;disabled&quot;: false}' http://localhost:5244/api/admin/user/update clouddrive 的 shell 启动脚本12wget -q https://gist.githubusercontent.com/ChenyangGao/e8e520de651e6375dad552b5a761902f/raw/clouddrive.sh -O ~/clouddrive.shchmod +x ~/clouddrive.sh 用法和例子如下 123456789101112131415161718192021222324$ ~/clouddrive.sh&gt;&gt;&gt; 帮助信息start 启动 clouddrive。可指定 -d 后台运行。————————————————————stop 停止 clouddrive。————————————————————restart 重启 clouddrive。可指定 -d 后台运行。————————————————————status 显示 clouddrive 的进程信息。————————————————————log 显示 clouddrive 的日志信息。————————————————————enable 打开终端后自动启动 clouddrive，可指定一个 rcfile 的路径作为参数，否则自动根据默认 shell 来确定。 通过在默认 SHELL 的 rcfile 文件中写入启动命令来实现，日志在 ~/clouddrive.log。————————————————————disable 去除 enable 注册的启动，可指定一个 rcfile 的路径作为参数，否则自动根据默认 shell 来确定。————————————————————startup 等同于 enable。————————————————————unstartup 等同于 disable。$ # 开启 clouddrive 随 Termux 启动$ ~/clouddrive.sh enable$ # 后台运行 clouddrive$ ~/clouddrive.sh start -d 扩展知识OpenWrt 是一个开源的嵌入式操作系统，专门为路由器和其他嵌入式设备设计。它基于 Linux内核，并提供了一套完整的系统软件包，用于构建和定制网络设备的固件。通过 OpenWrt，用户可以自定义配置和扩展功能，并享受强大的网络管理和路由功能。通过一些适当的扩展，OpenWrt 可以作为 NAS 使用，下面是一些其它的嵌入式 NAS 系统： openmediavault：一个基于 Debian Linux 的开源 NAS 系统，设计用于家庭和小型办公室环境。它提供了易于使用的管理界面和丰富的功能，如文件共享、远程访问、备份、媒体服务器等。 FreeNAS：一个免费的网络存储操作系统，基于 FreeBSD。用于构建和管理网络存储服务器。它提供了 ZFS 文件系统、数据共享、备份和恢复、多媒体服务等功能，适用于家庭用户和小型企业。 XigmaNAS：它是 FreeNAS 项目的前身，也是基于 FreeBSD 的，提供了类似 FreeNAS 的功能。历史上，它经过了数次改名。 OpenNAS：这是一个基于 OpenMediaVault 的衍生项目，也是一个网络存储解决方案，提供了类似的功能和界面，可以用于搭建家庭或小型办公室的网络存储服务器。 我在我的树莓派上安装了 OpenWrt，并修改了一些网络配置： HOWTO: OpenWrt on the Raspberry Pi 4 OpenWRT on Pi – Light OS with Network Features Turn your Raspberry Pi into a WiFi Router using OpenWrt Raspberry Pi x OpenWRT Travel Router 树莓派入门指南｜明明白白玩 Pi 系列 树莓派实验室 这样我的树莓派就是一个 NAS，再用 AList 和 clouddrive 挂载几个网盘，使用体验非常令人满意。","link":"/2023/08/02/14.%E5%9C%A8Linux:MacOSX%E4%B8%8A%E9%83%A8%E7%BD%B2AList%E5%92%8Cclouddrive/"},{"title":"CPython中函数的非本地变量","text":"函数对象的特殊属性 NOTE 当前测试的CPython解释器版本为 123&gt;&gt;&gt; print(__import__('sys').version)3.7.3 (default, Mar 27 2019, 16:54:48)[Clang 4.0.1 (tags/RELEASE_401/final)] 以当前版本的解释器下执行下面的代码，可得到一个Markdown表格 1234567891011121314151617def outer(freevar=None): def inner(a, b: int=1, *args, c: str='1', **kwds) -&gt; tuple: 'a test function' return freevar, a, b, args, c, kwds return innerfn = outer()print('attribute', 'type', 'setable', 'reason', sep=' | ')print(*'-'*4, sep=' | ')for attr in dir(fn): try: obj = getattr(fn, attr) setattr(fn, attr, obj) print('`%s`'%attr, type(obj), True, '', sep=' | ') except Exception as exc: print('`%s`'%attr, type(obj), False, '`%s`'%exc, sep=' | ') attribute type setable reason __annotations__ &lt;class ‘dict’&gt; True __call__ &lt;class ‘method-wrapper’&gt; True __class__ &lt;class ‘type’&gt; False __class__ assignment only supported for heap types or ModuleType subclasses __closure__ &lt;class ‘tuple’&gt; False readonly attribute __code__ &lt;class ‘code’&gt; True __defaults__ &lt;class ‘tuple’&gt; True __delattr__ &lt;class ‘method-wrapper’&gt; True __dict__ &lt;class ‘dict’&gt; True __dir__ &lt;class ‘builtin_function_or_method’&gt; True __doc__ &lt;class ‘str’&gt; True __eq__ &lt;class ‘method-wrapper’&gt; True __format__ &lt;class ‘builtin_function_or_method’&gt; True __ge__ &lt;class ‘method-wrapper’&gt; True __get__ &lt;class ‘method-wrapper’&gt; True __getattribute__ &lt;class ‘method-wrapper’&gt; True __globals__ &lt;class ‘dict’&gt; False readonly attribute __gt__ &lt;class ‘method-wrapper’&gt; True __hash__ &lt;class ‘method-wrapper’&gt; True __init__ &lt;class ‘method-wrapper’&gt; True __init_subclass__ &lt;class ‘builtin_function_or_method’&gt; True __kwdefaults__ &lt;class ‘dict’&gt; True __le__ &lt;class ‘method-wrapper’&gt; True __lt__ &lt;class ‘method-wrapper’&gt; True __module__ &lt;class ‘str’&gt; True __name__ &lt;class ‘str’&gt; True __ne__ &lt;class ‘method-wrapper’&gt; True __new__ &lt;class ‘builtin_function_or_method’&gt; True __qualname__ &lt;class ‘str’&gt; True __reduce__ &lt;class ‘builtin_function_or_method’&gt; True __reduce_ex__ &lt;class ‘builtin_function_or_method’&gt; True __repr__ &lt;class ‘method-wrapper’&gt; True __setattr__ &lt;class ‘method-wrapper’&gt; True __sizeof__ &lt;class ‘builtin_function_or_method’&gt; True __str__ &lt;class ‘method-wrapper’&gt; True __subclasshook__ &lt;class ‘builtin_function_or_method’&gt; True 命名空间和作用域 NOTE 在传统的编程语言中，作用域（scope）就是一段程序代码中所用到的名字被限制的可用范围。本地（局部，local）作用域被限制在块或函数体内，而全局（global）作用域被限制在本地以上最长可达程序的生命周期结束。有些编程语言允许，在本地作用域内构建一个更低层次的本地作用域，低层作用域访问一个非本地的名字，它就会到较高层中寻找，逐层往上，直到找到或者最终不能找到。但是这会引出一个问题：定义在一个函数outer内的函数inner被作为返回值，inner中引用了inner中没有而在outer中有的名字，为了保证理论上的某些一致性，是否要求编译器提供一种被称为闭包（closure）的机制：outer中的这些名字及其引用应该继续保留在一个可被inner访问但对更高层作用域隐藏（并非指绝对不能被更高层发现）。程序执行过程中，必定会处于某个作用域中，作用域其实是在维护一些名字对一些资源的占用关系。一旦程序离开某个作用域，那么注销其中的名字和释放对相关资源的占用往往被认为是唯一正确的。在CPython中，命名空间（namespace）和作用域虽然联系紧密，但却是两个不同的概念。在传统的编程语言C中，全局作用域建立在堆上，而本地作用域建立在栈上，但是在Python中，命名空间实际上就是个字典，而回收资源又是另一回事了，不再是“销毁”，只是“解除”对资源的引用关系。对资源的管理基于另一套机制（引用计数和垃圾回收），它代理了资源的创建和销毁的操作，它依靠建立统计信息来实现有效的管理。相关的情况非常复杂，但简单来说：更新全局命名空间globals()，会改变模块级别作用域中相应变量的值，但是更新本地命名空间locals()，其实际效果视所处情况会有所不同。在函数内还可以有本地作用域一说，但模块级别还是低于传统的全局概念的，在其上尚有builtins一级，而且解除一个模块对资源的占用关系更是轻而易举。命名空间也存在低级对高级的遮盖，这在面向对象中甚至可用来实现多态（polymorphism）。 NOTE CPython中对名字的寻找顺序：locals &gt; closure &gt; globals &gt; builtins 1. 全局命名空间和模块作用域 更新全局命名空间globals()，会同时更新模块作用域中的变量 1234&gt;&gt;&gt; val = 0&gt;&gt;&gt; globals()['val'] = 1&gt;&gt;&gt; val1 2. 模块作用域中的本地命名空间 在模块作用域中，本地命名空间locals()等同于全局命名空间globals() 123456&gt;&gt;&gt; locals() is globals()True&gt;&gt;&gt; val = 0&gt;&gt;&gt; locals()['val'] = 1&gt;&gt;&gt; val1 3. 函数本地作用域中的本地命名空间 在本地作用域中，本地命名空间locals()的更新并不影响本地作用域中变量的值，反之不然 1234def fn(): val = 0 locals()['val'] = 1 return val 12&gt;&gt;&gt; fn()0 12345def fn(): val = 0 print(locals()['val']) val = 1 print(locals()['val']) 123&gt;&gt;&gt; fn()01 本地命名空间locals()包含本地作用域的名称和自由变量 12345678def outer(): nval = 0 def inner(): global gval nonlocal nval lval = 1 return locals() return inner 123&gt;&gt;&gt; gval = 0&gt;&gt;&gt; outer()() # ⚠️ 注意结果的顺序{'lval': 1, 'nval': 0} 4. 本地命名空间和本地作用域的更新对闭包的影响 和在本地作用域的赋值不同，对本地命名空间locals()的更新，不能为闭包所侦测和使用 1234567val = 0def outer(mapping): locals().update(mapping) def inner(): return val return inner 12&gt;&gt;&gt; outer(dict(val=1))()0 123456def outer(mapping): val = 0 locals().update(mapping) def inner(): return val return inner 12&gt;&gt;&gt; outer(dict(val=1))()0 并且在本地作用域的赋值，必须是显式的，使用exec和eval，同样只会更新相应的gloabls和locals 123456def outer(mapping): for key in tuple(mapping): exec(f'{key}={key}', mapping, locals()) def inner(): return val return inner 12&gt;&gt;&gt; outer(dict(val=1))()NameError: name 'val' is not defined 123456def outer(mapping): for key in tuple(mapping): eval(compile(f'{key}={key}', '', 'single'), mapping, locals()) def inner(): return val return inner 12&gt;&gt;&gt; outer(dict(val=1))()NameError: name 'val' is not defined 总而言之，编程语言作为编译器或解释器的配置文件，编程语言的行为会受到解释器或编译器实现方式的限制。在CPython的实现中，在一定程度上可认为，本地作用域是静态的，本地命名空间是动态的，对本地作用域更新的过程，在编译时就已经确定了，而在运行时更新本地命名空间和动态编译代码执行，只会影响一些动态的局面。 函数利用缓存的研究 NOTE 一般地讲，系统A和系统B之间有通信，B可存储A发送过来的数据，并且当A索要时可原样返回，就能用B提供A的缓存需求。无论A用什么方式去访问B，它们之间的运作着怎样的通信协议，是本地还是通过网络。甚至B可以是A的一部分，或者A和B都是某个系统C的一部分，A借助了某些基础设施对B进行了操作，例如B是某个可读写存储器、它的驱动程序或者在存储器上构造的容器（container）数据结构和相关处理方法集合，就算这个存储器或数据结构在数据写入后就不可更改。一般的，当我们在说缓存时，其实是说：以任意方式，把数据存储在容器中，需要的时候就从容器中获取。虽然并不规定使用次数，但合理的策略是至少使用到1次，🚫 使用0次的不应缓存。实质上，缓存唯一问题是存储和访问，其它问题都是附加的。执行一次操作的结果被后续多次使用需求，就是业务问题对缓存的附加问题：把某个操作的结果存储起来，在以后需要用到时直接返回相应结果，而不是再次执行操作然后把结果返回。但一个操作，它可能：可进一步细分，操作的过程会改变一些对象的数据，多次执行的结果不同。缓存只是把结果存储起来，何时更新、何时失效取决于现实考虑和程序实现，如果需要使用缓存来自动处理其它问题，只要附加相关的处理逻辑即可。 NOTE 讨论一个特殊情形：假设函数fn需要引用某个数据，并且希望能在多次调用间持续。通常的做法是，在一个所属的高层命名空间或作用域中有名称绑定了这个引用或者这个名称所引用的容器直接或间接持有这个引用，然后在本地无冲突的策略下，使用名称和另外的间接操作去获取这个引用。使用名称去获取，并不保证每次获取的都是同一个引用，但在规则约束下，却是可以加以保证。 1. 定义在函数体中123def fn(): val = '&lt;time-consuming&gt;' return val NOTE 如果fn.__code__.co_consts包含这项计算结果（解释器隐含地缓存了这项常量），那么意味着这项计算只在函数编译时执行一次，这个方案就是可取的 某些字面量的简单计算 函数(def和lambda)和类的定义（缓存的是code对象，⚠️在函数内定义的类，类似函数） ⚠️ 缓存往往指的是一次操作的结果被多次使用，把数据保存在某个名称上，然后在需要使用的时间和地点，使用名称进行访问，那么广义上讲，保存在名称上的值，在其作用范围内，都是缓存的(cached)。 1234567val = '&lt;expr&gt;'...# 此处是`val`或者某个`val`的引用者的作用范围# 并包括`val`作为参数传入这个作用范围的情况use(val) ⚠️ 函数的基本信息在编译时就确定，在执行时又受到传入参数的影响。本地有哪些变量名，在编译时就确定，根据显式的赋值语句，以及函数和类的定义语句来判定。函数编译是一个多阶段的过程，如果函数b的定义嵌套在函数a的定义内，那么在a的本地变量名信息收集完成后，b才能被编译，但b的编译完成时间会早于a，b的某些上下文信息也会取自a，例如自由变量。⚠️ 本地作用域中变量的赋值（包括函数和类的定义）是一个复杂机制，远远不是修改本地命名空间的名称和值的映射关系那么简单。这类赋值，会去修改多个地方，栈、本地命名空间、闭包的自由变量对应cell对象的cell_contents等。这种复杂性也是有成本的，主要影响运行时的效率。 2. 定义在函数所在的全局命名空间中1234val = '&lt;time-consuming&gt;'def fn(): return val NOTE 这意味着会在全局命名空间中建立一个名称，有时候我们会认为，这是对全局命名空间的污染，尤其是当这个名称只被某一个函数用到时。函数的__globals__属性引用的就是所在的全局命名空间，不过这并不意味着这个命名空间保留着对它的引用。函数的__globals__属性是只读的，不过__code__属性是可替换的，可以创建一个功能相同的新函数，引用某个dict对象，充当它的全局命名空间。 1234567891011121314151617181920212223242526import functoolsfrom typing import Optional, TypeFunction = Type[type(lambda:None)]def redirect_globals( namespace: dict, fn: Optional[Function] = None) -&gt; Function: ''' 利用传入的命名空间`namespace`和函数`fn`，创建一个和`fn`功能和签名完全相同的函数， 但是__globals__属性为`namespace`的函数，要求`fn.__closure__`没有被设置 :param namespace: 作为新函数的全局命名空间 :param fn: 函数 :return: 和`fn`功能和签名完全相同，但全局命名空间为`namespace`的函数 ''' if fn is None: return functools.partial(redirect_globals, namespace) f = eval('lambda: None', namespace) # `fn`的自由变量个数不为0时，会抛出`ValueError`，意味着它其实是一个闭包 # 可根据`fn.__closure__`或`fn.__code__.co_freevars`判断 f.__code__ = fn.__code__ return functools.update_wrapper(f, fn) 3. 在函数的定义头中定义默认参数12def fn(val='&lt;time-consuming&gt;'): return val NOTE 在定义头中定义，只在函数编译时执行一次，允许是任何表达式，无论它有多复杂。不过这种做法也会被认为污染了函数的签名，对使用者造成困惑，即便参数名以下划线开头。 NOTE 在函数头中定义默认参数，自动设置了它的__defaults__和__kwdefaults__的属性，它们都是可替换的，而且__kwdefaults__是一个普通的字典，本身就是可改的。在函数调用时，新传入的参数会遮盖这些默认参数，具体行为如下： 12345678910111213141516&gt;&gt;&gt; def fn(foo=1, bar=2, *, baz='0'): return foo, bar, baz&gt;&gt;&gt; fn.__defaults__(1, 2)&gt;&gt;&gt; fn.__kwdefaults__{'baz': '0'}&gt;&gt;&gt; fn.__defaults__ = (1, 2, 3)&gt;&gt;&gt; fn.__defaults__['baz'] = 'inf'&gt;&gt;&gt; fn()(2, 3, 'inf')&gt;&gt;&gt; fn(1, 2, baz=3)(1, 2, 3)&gt;&gt;&gt; fn.__defaults__ = (0,)&gt;&gt;&gt; fn()Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: fn() missing 1 required positional argument: 'foo' ✍ 在定义头上的参数名称，是函数本地的，会计入fn.__code__.co_nlocals和fn.__code__.co_varnames中，但不会计入fn.__code__.co_consts中。位置参数计入fn.__code__.co_argcount，但可变长度参数不计入，例如*args。__defaults__和__kwdefaults__都是容器，这是解释器的自动缓存策略，编译函数除了生成机器（例如PVM）的字节码，还有收集上下文相关信息绑定到函数对象的过程。 4. 闭包12345678def outer(): val = '&lt;time-consuming&gt;' def fn(): return val return fnfn = outer()# del outer NOTE 如果使用闭包存粹是为了不污染全局命名空间，那么外层函数使用一次，把它的返回值绑定到一个变量后，就可以删除了。在Python中，使用def(也包括async def等def衍生)定义函数的构造被认为是语句而非表达式，用lambda定义函数的构造虽然是表达式，但是定义体中只允许用且只用1个表达式，运用这种技术就必须写一些冗余的代码。JavaScript的用户笑了😄，因为JavaScript中几乎所有结构都是表达式，意味着有返回值，这种性质可谓awesome。 1234fn = (function(){ val = '&lt;time-consuming&gt;'; return () =&gt; val;})() Python的函数，也有一个设计问题，就是它们的__closure__属性是只读的。这可以理解，因为__closure__实际上和__code__.co_freevars存在关系，即便函数的__code__属性可被替换，但也要和__closure__属性协调，即并非所有的替换都能被接受。如果想构造一个只是__closure__属性不同，功能相同的函数，其实是比较麻烦的。 1234567891011121314151617181920212223242526272829303132import functoolsimport inspectfrom typing import Optional, Type, MappingFunction = Type[type(lambda:None)]def use_closure( namespace: Mapping, fn: Optional[Function] = None) -&gt; Function: ''' 利用传入的命名空间`namespace`和函数`fn`，创建一个和`fn`功能和签名完全相同的函数， 但是__closure__属性可能有所不同的函数 :param namespace: `fn`中的非本地变量会尝试从这个映射中提取 :param fn: 函数 :return: 和`fn`功能和签名完全相同，但尝试从`namespace`获取一些值来构建__closure__ ''' if fn is None: return functools.partial(use_closure, mapping) assign = '\\n '.join(map('{0} = __[&quot;{0}&quot;]'.format, mapping)) # 获取的源代码，可能是不可用的，或者可能获取不到，对于lambda函数，这样的处理也是不适合的 source = ' '.join(inspect.getsourcelines(fn)[0]) exec(f'''def outer(__): {assign} {source} return {fn.__name__}''', fn.__globals__, locals()) return functools.update_wrapper(locals()['outer'](mapping), fn) NOTE 虽然函数的__closure__属性不可更改，但是__closure__中所有cell对象的cell_contents是可更改的。完全可以精心设计函数定义，先占用几个__closure__位置，在以后需要的时候进行更改。 12345def outer(): val: int = 1 def inner(): return val return inner 12345678&gt;&gt;&gt; fn = outer()&gt;&gt;&gt; fn.__closure__(&lt;cell at 0x10e375d68: int object at 0x10e0105a0&gt;,)&gt;&gt;&gt; fn.__closure__[0].cell_contents = 'foo'&gt;&gt;&gt; fn.__closure__(&lt;cell at 0x10e375d68: str object at 0x10e3dd180&gt;,)&gt;&gt;&gt; fn()'foo' ✍ 但我建议一种更为集中的管理办法，把数据保存到映射容器里面，推荐dict 12345678def outer(): _closure_ns: dict = {} def inner(): if 'val' not in _closure_ns: _closure_ns['val'] = '&lt;time-consuming&gt;' val = _closure_ns['val'] return i return inner 5. nonlocal和global NOTE nonlocal用于声明某个名称是自由变量（非本地和模块层次，属于闭包层次作用域），而global用于声明某个名称是全局变量（globals()，模块层次作用域）。当一个函数调用结束后，在本地作用域建立的所有名称都会被销毁（体现为它们所引用对象的引用计数自动减小相应数目），包括： 本地赋值的名称 定义头中的名称 nonlocal和global声明的名称 2.中的默认参数和3.都有自动缓存，但每次执行时都需要拿缓存执行赋值，并不等同于传统语言的静态变量。当在本地用赋值语句修改自由变量的值时，会自动更新函数的__closure__中相应cell对象的cell_content的值，修改全局变量则时更新对应的模块层次命名空间globals()中的名称和值的映射关系。 6. 容器 NOTE 容器包括作用域、命名空间、物理存储区域在逻辑上的管理机制等。缓存只是容器的运用之一，容器主要的功能在于实现程序的动态和数据的集中（更一般的说，数据结构实现了数据的秩序，容器是一类数据结构）。 NOTE 在函数的多次调用间持续引用需利用非本地的容器缓存： 存储于比函数本地的更高层的作用域或命名空间者函数的默认参数中，一个Python函数会自动寻找未在本地声明而需要用到的名称； 或者存储于上述非本地名称所引用的容器中。 ✍ 如果把缓存的使用封装到一条指令中，例如函数，它以上述方式引用了一个外部容器，由此可实现惰性计算和缓存。对于纯函数，相同的参数传入返回相同的结果，那么把具体参数和相应返回值建立关联，存入一个映射型容器中，那么每个不同的参数传入只需要计算一次。如果让函数自动维护缓存，需要增加对容器的查询和写入的操作，查询是每次执行，写入执行一次（若有缓存删除则次数取决于算法和实际情况），这也是有成本的，需要和计算的成本进行权衡取舍。functools.lru_cache实现了 Least Recently Used 算法的缓存管理，缓存并非一直有效，当长时间不用的缓存将会被清理。这不是唯一的缓存管理算法，例如你还可以使用 LFU(Least Frequently Used) 等算法。 ✍ 命名空间（namespace）实际上是一个映射型的数据结构，尤其是散列表，被广泛用于充当命名空间。所谓名称定义在某个命名空间，实际上就是在命名空间有这个名称的名称-值对，访问某个命名空间中的某个名称，就是在这个命名空间中这个名称的名称-值对中的值。通过名称，访问作用域或命名空间这类容器中的值，只能确保名称是确定的，而值要取得后才能确定，或者说，如果值发生变更那么取得值也是不同的，这让情况变得相当灵活和复杂多变。","link":"/2019/04/30/2.CPython%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E9%9D%9E%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F/"},{"title":"利用异常实现越级return（Python实现）","text":"异常是一类消息在面向对象的世界里，对象之间的交互表现为消息的传递。 异常也是一种消息，就我的理解，异常并非错误，它经常用来表明存在错误，但本质上它是一类特殊的消息，关联着一种跳出局部范围的机制。 It is my understanding that exceptions are not errors, and that they should only be used for exceptional conditions (e.g. I try to write a file into disk and there is no more space, or maybe I do not have permission), and not for flow control. —— Is it a good practice to use try-except-else in Python? 而在Python的世界里，所有异常都必须是BaseException的子类。所谓异常是消息，指的是一个异常对象可以携带信息，捕获异常（就得到了一个异常对象）或者传递一个异常对象，你就可以从这个异常对象中提取信息。这个消息有时会被认为是一个指令或者信号，即便仅仅只是捕获到了一个特定类型的异常对象，例如，某个无限循环中有一个捕获异常的语句，当捕获到某个类型的异常对象时，它就认为接收到了退出的信号，快速、优雅地退出。 处理异常的语句是流程控制语句当异常发生时，异常现场所在的局部范围就将被丢弃，并且把相关统计信息存储在一个异常对象中向上冒泡。所谓的局部范围，包括控制语句内部、局部作用域等层次结构中。如果定义了一个关于异常的类型系统，那么就会配套实现对异常现场的信息搜集策略、异常的冒泡机制和处理异常的语句。处理异常的语句，专门针对异常消息，会根据条件来判定，对某个异常是放行还是压下。这种流程控制，设计专门用来控制异常对局部范围的破坏。 异常是一种强化版的return一个函数调用完成时，就会在调用它的地方返回一个值。调用完成，意味着以下3种含义之一： 执行完函数体中的代码，自动返回 遇到return语句，返回 抛出异常 当函数调用完成后，将会销毁调用时所临时创建的局部作用域并回收相关资源。如果函数a在它的函数体内调用了函数b，而b中冒泡了一个异常，未能在a中压下，那么就会在a冒泡给a的调用者。在多层次调用结构中，如果到达顶级层次依然不能被压下，那么程序将会退出。在一些解释器、虚拟机或者某些具有监控功能的执行环境中，程序因为异常退出时，将会自动记录下相关的信息，便于开发者理解问题所在。抛出异常，未能被压下，将会不断地往上冒泡，并让局部环境不可被再次利用，程序的执行环境将自动回收这个局部环境所占用的资源。不过异常可以引用其它对象，可以被捕获，从中提取信息。正因为可以在退出函数时携带信息冒泡给函数的调用者，所以我说异常是一种强化版的return，调用者完全可以压下异常，从里面取出信息，就像是return给它的一样。 在Python中用异常实现一个越级return机制leepfrog.py123456789101112131415161718192021222324252627282930313233import functools__all__ = ['BubbleReturnSignal', 'leepfrog']class BubbleReturnSignal(Exception): '''使用这个异常作为一个return信号，可以实现在多层 调用中，快速退出n个调用层，并存储了一个返回值`r` :param n: 要跳出的调用层次层数 :param r: 返回值，默认为None ''' def __init__(self, n: int, r=None): self.n = n self.r = r def test(self): if self.n &lt;= 0: return self.r else: self.n -= 1 raise selfdef leepfrog(fn): '这个装饰器，使函数自动处理BubbleReturnSignal异常信号，让调用层的退出自动进行' def wrapper(*args, **kwds): try: return fn(*args, **kwds) except BubbleReturnSignal as exc: return exc.test() return functools.update_wrapper(wrapper, fn) 下面文件中定义的函数，用于测试说明leepfrog装饰器函数的功用 123456789101112131415161718192021222324252627282930313233343536373839404142import functoolsfrom leepfrog import leepfrogdef test(fn): '测试函数，打印一些信息，用于说明' def wrapper(*args, **kwds): try: return fn() except Exception as exc: print(f'函数名称: {fn.__qualname__}\\t异常参数: {exc.args}\\t剩余冒泡: {exc.n}') raise return functools.update_wrapper(wrapper, fn)@test@leepfrogdef foo1(): return foo2()@test@leepfrogdef foo2(): return foo3()@test@leepfrogdef foo3(): return foo4()@test@leepfrogdef foo4(): return foo5()@test@leepfrogdef foo5(): return bar()@testdef bar(): raise BubbleReturnSignal(4, 'value') 测试结果如下： 12345678&gt;&gt;&gt; value = foo1()函数名称: bar 异常参数: (4, 'value') 剩余冒泡: 4函数名称: foo5 异常参数: (4, 'value') 剩余冒泡: 3函数名称: foo4 异常参数: (4, 'value') 剩余冒泡: 2函数名称: foo3 异常参数: (4, 'value') 剩余冒泡: 1函数名称: foo2 异常参数: (4, 'value') 剩余冒泡: 0&gt;&gt;&gt; value'value'","link":"/2019/05/28/3.%E5%88%A9%E7%94%A8%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E8%B6%8A%E7%BA%A7return%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/"},{"title":"python的字典和集合的退化","text":"Python 的字典 dict 和集合 set 以 hashable 作为 key，存储数据于其中，理想情况下，查询操作具有 $O(1)$ 的时间复杂度。但如果你想当然地认为，现实总是和理想差不太多，那么就可能会掉入一个陷阱之中。 操作 数组 (Array) 链表 (Linked List) 散列表 (Hash Table) 增（插入） $O(n)$ （中间） / $O(1)$ （末尾） $O(n)$ （需要遍历） 平均 $O(1)$ 删（删除） $O(n)$ （中间） / $O(1)$ （末尾） $O(n)$ （需要遍历） 平均 $O(1)$ 查（查找） $O(1)$ （按索引） / $O(n)$ （按值） $O(n)$ 平均 $O(1)$ 改（修改） $O(1)$ （按索引） $O(n)$ 平均 $O(1)$ Python 实现字典和集合，利用了 hash 表。存储元素到 hash 表时，首先会用散列函数对元素计算 hash 值，然后相同 hash 值的元素，会存储在同一个链表之中。这个 hash 函数，就是元素的类上所定义的 __hash__ 特殊方法，会以元素进行计算然后得到一个整数值。Python 判断一个元素是否在字典和集合中（__contains__），还要判断元素是否相等 （__eq__，默认比较元素的内存地址，即 id）。首先是找到元素的 hash 值所在的链表，然后对链表元素进行逐个比对，仅当相等时才认为元素在其中，在链表中查找的时间复杂度是 $O(n)$。也就是说，字典和集合在最坏情况下，查询的时间复杂度就是 $O(1 * n)$，即 $O(n)$。 所以，如果一大堆元素有相同的 hash 值，则存储它们的字典或集合会发生退化。 现在假设你有这样一个类，它总是对任何实例，计算出的 hash 值为 0。 123class A: def __hash__(self, /) -&gt; int: return 0 然后分别创建列表、字典和集合，为了测量耗时，我在 IPython 中执行了代码。 123In [2]: %time list0 = [A() for _ in range(10000)]CPU times: user 2.38 ms, sys: 132 μs, total: 2.51 msWall time: 2.51 ms 123In [3]: %time dict0 = {A(): None for _ in range(10000)}CPU times: user 846 ms, sys: 1.3 ms, total: 847 msWall time: 850 ms 123In [4]: %time set0 = {A() for _ in range(10000)}CPU times: user 718 ms, sys: 1.13 ms, total: 719 msWall time: 721 ms 可以看到，在集合和字典中新增元素，比在列表中慢的多得多，而集合比字典快一些，因为集合的结构更简单一些。之所以都比列表慢那么多，是因为集合和字典在新增、删除或修改时，也要先查询元素是否在其中，然后才能执行实际的操作，而在查询上退化为 $O(n)$，在新增、删除或修改 $n$ 个元素时，时间复杂度也会退化为 $O(n^2)$。 另外在 Python 中，列表的查询速度，却又比链表快一倍 12In [5]: %timeit A() in list084.8 μs ± 77.4 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each) 12In [6]: %timeit A() in set0156 μs ± 648 ns per loop (mean ± std. dev. of 7 runs, 10,000 loops each) 12In [7]: %timeit A() in dict0124 μs ± 1.01 μs per loop (mean ± std. dev. of 7 runs, 10,000 loops each) 不过有趣的是，字典的查询速度，比集合快了一些。","link":"/2025/08/20/15.python%E7%9A%84%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%E7%9A%84%E9%80%80%E5%8C%96/"},{"title":"CPython中函数引用它自身","text":"⚠️ 请确保CPython的版本不低于3.8，因语法涉及2个PEP：PEP570，PEP572 问题 启发自这篇问答：Is there a generic way for a function to reference itself?曾有一个提议PEP 3130 – Access to Current Module/Class/Function，但是因为方案不完善而被拒绝了 就像__class__在函数体内指向于调用这个函数的类，是否有一个指针或者说魔法关键词，例如__func__，在函数体内使用时，能指向被调用的函数本身？因此，我可以写出像下面这样的代码： 12345def foo(): print(__func__.__name__) print(__func__.__hash__) print(__func__.__code__) ... # other simliars 解决方案 暂时还没有这样的一个指针和魔法关键词，起码就python 3.8来看。因此暂时只能用一些侵入式的方案，来模拟实现这一需求。 通过调用栈信息来获取函数引用我可以在一个函数的函数体内访问这个函数本身，通过以下代码： 12345def foo(): print(foo.__name__) print(foo.__hash__) print(foo.__code__) ... # other simliars 因为以上方式需要显式地指定函数名，当函数名发生改变时，函数体内相应的名字也要进行改变。为了避免这一点，需要函数有充足的信息以定位自身。例如，当可以通过函数在定义时的名字在相应的全局命名空间中查找引用时 这个名字存储于function.__code__.co_name：如果用def func_name或者async def func_name创建函数，func_name就是名字；如果用lambda创建函数，名字就是&lt;lambda&gt;，我特别不建议如此。⚠️ 这个属性co_name是只读的且不能被改变。但你可以自己创建一个新的code对象，复制相同的功能，选用不同的名字。⚠️ 这里并没有用到function.__name__，这个属性是可变的，而且更加灵活和合适，但是相对来说获取困难，所以不采用。特别是，function.__qualname__也同样难以获得，不然可以统一地解决很多问题了。Note Name of a Python function ，就可以使用以下帮助函数来获取这个函数的引用： 1234567891011121314151617181920import sysdef getfuncref(): ''' Get a reference to the `function` which is called recently in this thread，as long as the key where in `globals` that point to the function is equal to `function.__code__.co_name`. ''' # REF: https://www.oreilly.com/library/view/python-cookbook/0596001673/ch14s08.html # This introspective task is easily performed with sys._getframe. # This function returns a frame object whose attribute f_code is # a code object and the co_name attribute of that object is the # function name. # By calling sys._getframe(1), you can get this information # for the caller of the current function. So you can package # this functionality into your own handy functions. # This calls sys._getframe with argument 1, because the call # to `getfuncref` is now frame 0. f = sys._getframe(1) return f.f_globals[f.f_code.co_name] See Also http://code.activestate.com/recipes/66062/ https://stackoverflow.com/questions/33162319/how-can-get-current-function-name-inside-that-function-in-python https://stackoverflow.com/questions/21218416/reference-to-the-function-from-inside-itself-like-arguments-callee-in-javascrip https://stackoverflow.com/questions/4492559/how-to-get-current-function-into-a-variable https://stackoverflow.com/questions/5067604/determine-function-name-from-within-that-function-without-using-traceback … 测试结果如下： 123&gt;&gt;&gt; def foo(): return getfuncref()&gt;&gt;&gt; foo is foo()True Note 截至python 3.8，调用栈的帧frame（frame-objects）上并没有对函数对象的引用，只是引用了函数相应的code对象，以及相关的执行环境信息。因此，通过审查调用栈来获取函数function调用时对应的帧frame的信息，以获取function的引用，需要根据一些信息以间接方式在相关的命名空间上搜索。而且由于code对象上没有存储函数的描述信息（尽管这种策略有利于code对象的复用），如果函数定义在类中，那么定位这个函数的策略将会比较复杂，因为有一些不同的情况需要分别对待，而且可能还需要一些另外的信息。🔔 我觉得你可以利用inspect模块来辅助收集信息。 通过把函数的引用绑定到参数上可以通过在调用函数时传入这个函数的引用，在函数体内使用： 12345def foo(__func__, /): print(__func__.__name__) print(__func__.__hash__) print(__func__.__code__) ... # other simliars 为此，我设计了3个装饰器来实现一种绑定效果 123456789101112131415161718192021from functools import partial, update_wrapper############### plan 1 ###############def partial_bind_func(f, /): 'Decorate function `f` to pass a reference to the function as the first argument' return update_wrapper(partial(f, f), f)############### plan 2 ###############def method_bind_func(f, /): 'Decorate function `f` to pass a reference to the function as the first argument' return f.__get__(f, type(f))############### plan 3 ###############import inspectdef assign_bind_func(f, /): 'Decorate function `f` to pass a reference to the function as the first argument' wrapper = update_wrapper(lambda *a, **k: f(f, *a, **k), f) params = tuple(inspect.signature(f).parameters.values()) wrapper.__signature__ = inspect.Signature(params[1:]) return wrapper 测试结果如下： 123456789&gt;&gt;&gt; def foo(__func__, /, a, *b, c, **d): pass&gt;&gt;&gt; inspect.signature(foo)&lt;Signature (__func__, /, a, *b, c, **d)&gt;&gt;&gt;&gt; inspect.signature(partial_bind_func(foo), follow_wrapped=False)&lt;Signature (a, *b, c, **d)&gt;&gt;&gt;&gt; inspect.signature(method_bind_func(foo))&lt;Signature (a, *b, c, **d)&gt;&gt;&gt;&gt; inspect.signature(assign_bind_func(foo))&lt;Signature (a, *b, c, **d)&gt;","link":"/2019/07/12/5.CPython%E4%B8%AD%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8%E5%AE%83%E8%87%AA%E8%BA%AB/"},{"title":"Python把HTML中的img元素的src转换成datauri","text":"背景有时候，我们编写完 markdown 文档，为了便于分享阅读，会把它转换成 HTML 文档。但是，大多数的 markdown 转 HTML 工具，只会保留外部资源链接，而不是把资源整合到 HTML 文档之中。如果是网络资源，只要联网就能下载，如果是本地资源，那么必须把对应文件也一起打包，分享给别人。 我个人觉得，分享一个单独的 HTML ，而不是一个 HTML 以及一堆文件的打包，可以更方便用户的阅读。这里，我分享一个 Python 脚本，可以把一个 HTML 文档中所有 &lt;img&gt; 元素中的 src 属性的值，转换成 datauri （更现代的称呼是 data URL，详阅：Data URLs | MDN） 代码实现 TIPS 代码的最新版本在 GitHub Gist 中维护https://gist.github.com/ChenyangGao/5088ae89bc7359b5c931343f5e690e87 文件名称是 html_img_src2datauri.py，是一个命令行工具，Python 实现代码如下： html_img_src2datauri.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#!/usr/bin/env python3# coding: utf-8__author__ = &quot;ChenyangGao &lt;https://chenyanggao.github.io/&gt;&quot;__version__ = (0, 1, 1)__all__ = [&quot;func_cmdline&quot;]# Inspired by:# - https://pypi.org/project/typer/import inspectfrom argparse import ArgumentParser, Namespace, RawDescriptionHelpFormatterfrom functools import partialfrom textwrap import dedent, indentfrom typing import Callable, Optionaldef func_cmdline( fn: Optional[Callable] = None, /, parser: Optional[ArgumentParser] = None, parse_map: dict[type, Callable] = {}, helpinfo_map: dict[str, str] = {}, ) -&gt; Callable: &quot;&quot;&quot;装饰器让一个函数，可以作为命令行使用 :param fn: 被装饰的函数 :param parser: 命令行解析器对象 :param parse_map: 不同类型的解析函数的映射， 字符串通过相应的解析函数来转换成对应对象， 如果没有相应的解析函数，则尝试用对象本身 （它的构造器） :param helpinfo_map: 不同参数的帮助说明， 用于命令行的帮助信息 :param: 返函数`fn`本身，只是它身上绑定了几个属性 .parser 字段，使用的命令行解析器对象 .parse() 方法，解析命令行参数 .run() 方法，解析命令行参数并运行函数`fn`， 返回函数`fn`的执行结果 :return: 被装饰函数本身，添加了几个属性 &quot;&quot;&quot; if fn is None: return partial( func_cmdline, parser=parser, parse_map=parse_map, helpinfo_map=helpinfo_map, ) params = inspect.signature(fn).parameters if parser is None: parser = ArgumentParser( formatter_class=RawDescriptionHelpFormatter) if parser.epilog is None: parser.epilog = &quot;&quot; if fn.__doc__ is not None: parser.epilog += &quot;documentation:\\n&quot; + \\ indent(fn.__doc__, &quot; &quot;) parser.epilog += &quot;\\n\\nsource code:\\n&quot; + \\ indent(dedent(inspect.getsource(fn)), &quot; &quot;) abbrs: dict[str, int] = {} for name, param in params.items(): kargs: dict = {&quot;dest&quot;: name, &quot;help&quot;: helpinfo_map.get(name)} kind = param.kind if kind is inspect._ParameterKind.VAR_POSITIONAL: kargs[&quot;required&quot;] = False kargs[&quot;nargs&quot;] = &quot;*&quot; kargs[&quot;default&quot;] = [] elif kind is inspect._ParameterKind.VAR_KEYWORD: continue default = param.default if default is inspect._empty: kargs.setdefault(&quot;required&quot;, True) else: kargs[&quot;default&quot;] = default anno = param.annotation if anno is not inspect._empty: if anno is bool: kargs[&quot;required&quot;] = False if &quot;default&quot; in kargs: if kargs[&quot;default&quot;]: kargs[&quot;action&quot;] = &quot;store_false&quot; else: kargs[&quot;action&quot;] = &quot;store_true&quot; else: kargs[&quot;action&quot;] = &quot;store_true&quot; elif anno is list: kargs[&quot;nargs&quot;] = &quot;*&quot; elif getattr(anno, &quot;__origin__&quot;, None) is list and len(anno.__args__) == 1: kargs[&quot;nargs&quot;] = &quot;*&quot; kargs[&quot;type&quot;] = parse_map.get(anno.__args__[0], anno.__args__[0]) else: kargs[&quot;type&quot;] = parse_map.get(anno, anno) names = [] first_letter = name[0] n = abbrs.setdefault(first_letter, 0) if n == 0: abbr = first_letter else: abbr = f&quot;{first_letter}{n}&quot; abbrs[first_letter] += 1 names.append(f&quot;-{abbr}&quot;) names.append(f&quot;--{name}&quot;) if &quot;_&quot; in name: names.append(f&quot;--{name.replace('_', '-')}&quot;) parser.add_argument(*names, **kargs) def parse(argv: Optional[list[str]] = None) -&gt; Namespace: return parser.parse_args(argv) def run(argv: Optional[list[str]] = None): &quot;解析命令行参数，默认使用&quot; args = parser.parse_args(argv).__dict__ pargs = [] kargs = {} for name, param in params.items(): kind = param.kind if name in args: if kind.value &lt; 2: pargs.append(args[name]) elif kind.value == 2: pargs.extend(args[name]) else: kargs[name] = args[name] return fn(*pargs, **kargs) setattr(fn, &quot;parser&quot;, parser) setattr(fn, &quot;parse&quot;, parse) setattr(fn, &quot;run&quot;, run) return fnif __name__ == &quot;__main__&quot;: @func_cmdline(helpinfo_map=dict( a=&quot;参数a&quot;, b=&quot;参数b&quot;, c=&quot;参数c&quot;, d=&quot;参数d&quot;, e=&quot;参数e&quot;, f=&quot;参数f&quot;, )) def foo(a: int, /, b: bool, c: bool = True, *d: int, e: list[int], f: int = 4): &quot;Example for function as command line.&quot; print(a, b, c, d, e, f) foo.run() 使用说明在命令行中输入类似如下命令，可以获取帮助信息： 1python html_img_src2datauri.py -h 返回的帮助信息，大致如下： 12345678910111213141516usage: html_img_src2datauri.py [-h] [-e ENCODING] path_to_file_or_dir [path_to_file_or_dir ...]把 HTML 文件中 &lt;img&gt; 元素的 src 属性转换成 datauri。注意：所有HTML 文件会被原地替换，并不生成新文件positional arguments: path_to_file_or_dir html 所在的文件或文件 夹options: -h, --help show this help message and exit -e ENCODING, --encoding ENCODING html 文件的编码 现在假设，在当前的工作目录下，有 1 个 HTML 文件 3.html ，另外还有 1 个文件夹 src，里面有 2 个 HTML 文件，1.html、2.html，文档都采用 utf-8 编码，可以在命令行执行如下代码： 12# 4.html 并不存在，只是为了演示发生错误时的效果python html_img_src2datauri.py -e utf-8 src/ 3.html 4.html 可以得到如下打印信息： 123456789101112--------------------[PROCESSING] src/1.html😄 SUCCESS--------------------[PROCESSING] src/2.html😄 SUCCESS--------------------[PROCESSING] 3.html😄 SUCCESS--------------------[PROCESSING] 4.html😭 FAILED: [Errno 2] No such file or directory: '4.html' 未来规划正如我在前言中所提到的，要把外部资源整合到一个 HTML 中，那便不仅仅是图片了。我计划在之后的更新中，实现这一想法，而把图片整合进 HTML 中，只是作为尝试的第一步，所以，敬请期待我的后续更新。","link":"/2022/08/01/6.Python%E6%8A%8AHTML%E4%B8%AD%E7%9A%84img%E5%85%83%E7%B4%A0%E7%9A%84src%E8%BD%AC%E6%8D%A2%E6%88%90datauri/"},{"title":"Shell脚本实现在Linux命令行开启代理","text":"背景我们在 Linux 命令行中，经常会需要使用代理（参考：How To Use Proxy Server To Access Internet at Shell Prompt With http_proxy Variable，Linux Proxy Server Settings – Set Proxy For Command Line），以便能访问某些资源。 在我使用 Clash 开启了一个代理，端口为 7890 后，我常常用下面的 shell 代码在命令行中启用或取消代理。 12345678910111213141516171819# 可以把代码写入 bash 和 zsh 的启动文件中，新开 session 中可用#cat &gt;&gt; ~/.bashrc &gt;&gt; ~/.zshrc &lt;&lt; 'EOF'export proxy=localhost:7890# 如果是在 WSL 中，可以替换为下面的语句#export proxy=$(cat /etc/resolv.conf | grep -m 1 nameserver | awk '{ print $2 }'):7890;# proxy+ 命令用于启用代理alias proxy+='\\export https_proxy=http://$proxyexport http_proxy=http://$proxyexport all_proxy=socks5://$proxyexport no_proxy=localhost,127.0.0.1,::1echo &quot;proxy has been set to: $proxy&quot;curl ipinfo.io';# proxy- 命令用于停用代理alias proxy-='\\unset http_proxy https_proxy all_proxy no_proxyecho &quot;proxy has been cleared&quot;;curl ipinfo.io';#EOF 为了便于做到这一点，我从自己的偏好出发，编写了一个 shell 脚本，已经在 bash 和 zsh 中通过测试。 代码实现 TIPS 代码的最新版本在 GitHub Gist 中维护https://gist.github.com/ChenyangGao/b5abf2de8bb5a91753764f9403adcc99 文件名称为 mod-proxy.sh，代码中端口的默认值 PROXY_PORT 设为 7890，是 Clash 的默认端口，实现如下： mod-proxy.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#? 设置代理 ip，请运行 proxy# 获取帮助信息# AUTHOR='ChenyangGao &lt;https://chenyanggao.github.io/&gt;''# VERSION=0.2if [ -n &quot;${MOD_PROXY_sourced+x}&quot; ]; then return 0fi# inetutils (apt)# net-tools (yum)-proxy-get-local-ipv4-using-hostname() { hostname -I 2&gt;&amp;- | awk '{print $1}'}# iproute2-proxy-get-local-ipv4-using-iproute2() { # OR ip route get 1.2.3.4 | awk '{print $7}' ip -4 route 2&gt;&amp;- | awk '{print $NF}' | grep -Eo --color=never '[0-9]+(\\.[0-9]+){3}'}# net-tools-proxy-get-local-ipv4-using-ifconfig() { ( ifconfig 2&gt;&amp;- || ip addr show 2&gt;&amp;- ) | grep -Eo '^\\s+inet\\s+\\S+' | grep -Eo '[0-9]+(\\.[0-9]+){3}' | grep -Ev '127\\.0\\.0\\.1|0\\.0\\.0\\.0'}# 获取本机 IPv4 地址-proxy-get-local-ipv4() { set -o pipefail -proxy-get-local-ipv4-using-hostname || -proxy-get-local-ipv4-using-iproute2 || -proxy-get-local-ipv4-using-ifconfig}-proxy-get-local-ipv4-select() { local ips=$(-proxy-get-local-ipv4) local retcode=$? if [ $retcode -ne 0 ]; then return $retcode fi grep -m 1 &quot;^192\\.&quot; &lt;&lt;&lt;&quot;$ips&quot; || \\ grep -m 1 &quot;^172\\.&quot; &lt;&lt;&lt;&quot;$ips&quot; || \\ grep -m 1 &quot;^10\\.&quot; &lt;&lt;&lt;&quot;$ips&quot; || \\ head -n 1 &lt;&lt;&lt;&quot;$ips&quot;}-proxy-get-remote-ssh-ip-using-ssh-env() { ( [ -n &quot;$SSH_CLIENT&quot; ] &amp;&amp; awk '{print $1}' &lt;&lt;&lt;&quot;$SSH_CLIENT&quot; ) || \\ ( [ -n &quot;$SSH_CONNECTION&quot; ] &amp;&amp; awk '{print $1}' &lt;&lt;&lt;&quot;$SSH_CONNECTION&quot; )}-proxy-get-remote-ssh-ip-using-who() { who am i 2&gt;&amp;- | awk '{print $NF}' | grep '([^)]\\+)' | grep -o '[^()]\\+'}# 获取远程连接到本机的 ssh 客户端的 ip 地址-proxy-get-remote-ssh-ip() { -proxy-get-remote-ssh-ip-using-ssh-env || -proxy-get-remote-ssh-ip-using-who}# 默认的代理服务的主机地址，可以是 ip 或 域名PROXY_HOST=$(( -proxy-get-local-ipv4-select | head -n 1 ) || echo 127.0.0.1)# 默认的代理端口（clash 的默认端口是 7890），0-65535 之间的数字PROXY_PORT=7890-proxy-format-proxy() { if [ -z &quot;$1&quot; ]; then echo &quot;$PROXY_HOST:$PROXY_PORT&quot; elif [[ $1 == \\[* ]]; then # as ipv6 if [[ $1 == *\\] ]]; then # as without port echo &quot;$1:$PROXY_PORT&quot; else # as with port echo &quot;$1&quot; fi elif [[ $1 =~ ^[0-9]+(\\.[0-9]+){3}$ ]]; then # as ipv4 (without port) echo &quot;$1:$PROXY_PORT&quot; elif [[ $1 =~ ^:[0-9]+$ ]]; then # as bare port echo &quot;$PROXY_HOST$1&quot; elif [[ $1 == *:*:* &amp;&amp; $1 =~ ^[0-9a-zA-Z:]+$ ]]; then # as ipv6 (without port) echo &quot;[$1]:$PROXY_PORT&quot; elif [[ $1 != *:* ]]; then # as hostname without port echo &quot;$1:$PROXY_PORT&quot; else # no op, here may be a mistake echo &quot;$1&quot; fi}# 在 shell 中启用代理，默认采用本机上的 7890 端口的代理服务proxy-set() { local proxy=$(-proxy-format-proxy &quot;$1&quot;) export https_proxy=http://$proxy export http_proxy=http://$proxy export all_proxy=socks5://$proxy export no_proxy='localhost,127.0.0.1,::1' echo &quot;proxy has been set to: $proxy&quot; ## Get public ip in Linux command line ## NOTE curl ≈ wget -qO - # curl api.ipify.org # curl checkip.amazonaws.com # curl cip.cc # curl httpbin.org/ip # curl ifconfig.cat # ipv6 # curl ifconfig.co # ipv6 # curl ifconfig.io # ipv6 # curl ifconfig.me # curl ifconfig.net # ipv6 # curl inet-ip.info # curl ipinfo.io # 👍 # curl ipv4.icanhazip.com # curl ipv4.ident.me # curl ipv4.ip.gs # curl ipv4.ip.sb # curl ip-api.com # 👍 # curl ip.threep.top # curl ipecho.net/plain # curl myip.dnsomatic.com # 👎 # curl myip.ipip.net # curl https://checkipv4.dedyn.io # curl https://ip.tool.lu # dig +short myip.opendns.com @resolver1.opendns.com # dig ANY +short @resolver2.opendns.com myip.opendns.com curl ipinfo.io}alias proxy+=proxy-set# 在 shell 中启用代理，代理服务来自 ssh 连接到这台机器的远程机器（仅适用于局域网）proxy-set-from-remote() { -proxy-get-remote-ssh-ip 1&gt;&amp;- &amp;&amp; proxy-set $(-proxy-get-remote-ssh-ip)}alias proxy++=proxy-set-from-remote# 在 shell 中停用代理proxy-clear() { unset http_proxy https_proxy all_proxy no_proxy echo 'proxy has been cleared' curl ipinfo.io}alias proxy-=proxy-clear# 打印 export 命令，用于启用 shell 中的代理（来自这台机器，命令可在局域网中的其他机器上使用）proxy-export() { local proxy=$(-proxy-format-proxy &quot;$1&quot;) echo &quot;\\# 在 shell 中启用代理，命令可在局域网中的其他机器上使用export https_proxy=http://$proxyexport http_proxy=http://$proxyexport all_proxy=socks5://$proxyexport no_proxy='localhost,127.0.0.1,::1'# 用以下命令停用代理# unset http_proxy https_proxy all_proxy no_proxy&quot;}alias proxy@=proxy-export# 打印 alias 命令，用于启用和停用 shell 中的代理（来自这台机器，命令可在局域网中的其他机器上使用），其中：# proxy+ 在 shell 中启用代理# proxy- 在 shell 中停用代理proxy-alias() { local proxy=$(-proxy-format-proxy &quot;$1&quot;) cat &lt;&lt; EOF# 在 shell 中启用代理，命令可在局域网中的其他机器上使用alias proxy+=&quot;\\export https_proxy=http://$proxyexport http_proxy=http://$proxyexport all_proxy=socks5://$proxyexport no_proxy='localhost,127.0.0.1,::1'echo 'proxy has been set to: $proxy'curl ipinfo.io&quot;# 在 shell 中停用代理，命令可在局域网中的其他机器上使用alias proxy-=&quot;\\unset http_proxy https_proxy all_proxy no_proxyecho 'proxy has been cleared'curl ipinfo.io&quot;EOF}alias proxy@@=proxy-aliasalias proxy#='echo &quot;\\[环境变量]PROXY_HOST 默认的代理服务的主机地址，可以是 ip 或 域名PROXY_PORT 默认的代理端口（clash 和 ssr(shadowsocksR，酸酸乳) 等科学上网软件的默认端口是 7890），0-65535 之间的数字----------------------------------------[命令]proxy# 输出使用说明proxy+ 在 shell 中启用代理，默认采用本机上的 7890 端口（clash 和 ssr 等科学上网软件的默认端口）的代理服务。如果要指定端口，运行形如 PROXY_PORT=&lt;port&gt; proxy+proxy++ 在 shell 中启用代理，代理服务来自 ssh 连接到这台机器的远程机器（仅适用于局域网）。如果要指定端口，运行形如 PROXY_PORT=&lt;port&gt; proxy++proxy- 停用 shell 中的代理proxy@ 打印 export 命令，用于启用 shell 中的代理（来自这台机器，命令可在局域网中的其他机器上使用）proxy@@ 打印 alias 命令，用于启用和停用 shell 中的代理（来自这台机器，命令可在局域网中的其他机器上使用）&quot;'MOD_PROXY_sourced= 使用说明假设上面的代码位于 /path/to/mod-proxy.sh。要加载这个脚本，就在命令行运行如下命令 1source /path/to/mod-proxy.sh 或者修改当前用户所用 shell 的配置文件，对于 bash 就是 ∼/.bashrc ，对于 zsh 就是 ∼/.zshrc。把上面的命令添加到对应的配置文件中去。 打印帮助信息1234567891011121314$ proxy#[环境变量]PROXY_HOST 默认的代理服务的主机地址，可以是 ip 或 域名PROXY_PORT 默认的代理端口（clash 和 ssr(shadowsocksR，酸酸乳) 等科学上网软件的默认端口是 7890），0-65535 之间的数字----------------------------------------[命令]proxy# 输出使用说明proxy+ 在 shell 中启用代理，默认采用本机上的 7890 端口（clash 和 ssr 等科学上网软件的默认端口）的代理服务。如果要指定端口，运行形如 PROXY_PORT=&lt;port&gt; proxy+proxy++ 在 shell 中启用代理，代理服务来自 ssh 连接到这台机器的远程机器（仅适用于局域网）。如果要指定端口，运行形如 PROXY_PORT=&lt;port&gt; proxy++proxy- 停用 shell 中的代理proxy@ 打印 export 命令，用于启用 shell 中的代理（来自这台机器，命令可在局域网中的其他机器上使用）proxy@@ 打印 alias 命令，用于启用和停用 shell 中的代理（来自这台机器，命令可在局域网中的其他机器上使用） 打印 export 命令，在局域网的某台机器上启用本机上代理1234567891011121314151617# 可接受 1 个参数，用于指定 host:port。如果要单独指定 host，写作 host；如果要单独指定 port，写作 :port；如果省略参数，则用 $PROXY_HOST:$PROXY_PORT。$ proxy@# 在 shell 中启用代理，命令可在局域网中的其他机器上使用export https_proxy=http://192.168.1.2:7890export http_proxy=http://192.168.1.2:7890export all_proxy=socks5://192.168.1.2:7890export no_proxy='localhost,127.0.0.1,::1'# 用以下命令停用代理# unset http_proxy https_proxy all_proxy no_proxy$ proxy@ 192.168.1.66# 在 shell 中启用代理，命令可在局域网中的其他机器上使用export https_proxy=http://192.168.1.66:7890export http_proxy=http://192.168.1.66:7890export all_proxy=socks5://192.168.1.66:7890export no_proxy='localhost,127.0.0.1,::1'# 用以下命令停用代理# unset http_proxy https_proxy all_proxy no_proxy 上述命令输出几个 export 命令，可以在同一局域网中的任何 Linux 机器的命令行中运行，即可启用代理。 如果要取消代理，在那台机器的命令行中运行 1unset http_proxy https_proxy all_proxy no_proxy 打印 alias 命令，在局域网的某台机器上启用和停用本机上代理123456789101112131415161718192021222324252627# 可接受 1 个参数，用于指定 host:port。如果要单独指定 host，写作 host；如果要单独指定 port，写作 :port；如果省略参数，则用 $PROXY_HOST:$PROXY_PORT。$ proxy@@# 在 shell 中启用代理，命令可在局域网中的其他机器上使用alias proxy+=&quot;export https_proxy=http://192.168.1.2:7890export http_proxy=http://192.168.1.2:7890export all_proxy=socks5://192.168.1.2:7890export no_proxy='localhost,127.0.0.1,::1'echo 'proxy has been set to: 192.168.1.2:7890'curl ipinfo.io&quot;# 在 shell 中停用代理，命令可在局域网中的其他机器上使用alias proxy-=&quot;unset http_proxy https_proxy all_proxy no_proxyecho 'proxy has been cleared'curl ipinfo.io&quot;$ proxy@@ 192.168.1.66# 在 shell 中启用代理，命令可在局域网中的其他机器上使用alias proxy+=&quot;export https_proxy=http://192.168.1.66:7890export http_proxy=http://192.168.1.66:7890export all_proxy=socks5://192.168.1.66:7890export no_proxy='localhost,127.0.0.1,::1'echo 'proxy has been set to: 192.168.1.66:7890'curl ipinfo.io&quot;# 在 shell 中停用代理，命令可在局域网中的其他机器上使用alias proxy-=&quot;unset http_proxy https_proxy all_proxy no_proxyecho 'proxy has been cleared'curl ipinfo.io&quot; 上述命令可输出 2 个 alias 命令，可以在同一局域网中的任何 Linux 机器的命令行中运行，以生成别名： proxy+在 shell 中启用代理 123456789101112$ proxy+proxy has been set to: 192.168.1.2:7890{ &quot;ip&quot;: &quot;103.47.100.220&quot;, &quot;city&quot;: &quot;Sham Shui Po&quot;, &quot;region&quot;: &quot;Sham Shui Po&quot;, &quot;country&quot;: &quot;HK&quot;, &quot;loc&quot;: &quot;22.3302,114.1595&quot;, &quot;org&quot;: &quot;AS38136 Akari Networks&quot;, &quot;timezone&quot;: &quot;Asia/Hong_Kong&quot;, &quot;readme&quot;: &quot;https://ipinfo.io/missingauth&quot;} proxy-在 shell 中停用代理 123456789101112$ proxy-proxy has been cleared{ &quot;ip&quot;: &quot;111.3.34.208&quot;, &quot;city&quot;: &quot;Shanghai&quot;, &quot;region&quot;: &quot;Shanghai&quot;, &quot;country&quot;: &quot;CN&quot;, &quot;loc&quot;: &quot;31.2222,121.4581&quot;, &quot;org&quot;: &quot;AS56041 China Mobile communications corporation&quot;, &quot;timezone&quot;: &quot;Asia/Shanghai&quot;, &quot;readme&quot;: &quot;https://ipinfo.io/missingauth&quot;} shell 命令：proxy+、proxy++ 和 proxy-proxy+在 shell 中启用本机上代理 12345678910111213# 可接受 1 个参数，用于指定 host:port。如果要单独指定 host，写作 host；如果要单独指定 port，写作 :port；如果省略参数，则用 $PROXY_HOST:$PROXY_PORT。$ proxy+proxy has been set to: 192.168.1.2:7890{ &quot;ip&quot;: &quot;103.47.100.220&quot;, &quot;city&quot;: &quot;Sham Shui Po&quot;, &quot;region&quot;: &quot;Sham Shui Po&quot;, &quot;country&quot;: &quot;HK&quot;, &quot;loc&quot;: &quot;22.3302,114.1595&quot;, &quot;org&quot;: &quot;AS38136 Akari Networks&quot;, &quot;timezone&quot;: &quot;Asia/Hong_Kong&quot;, &quot;readme&quot;: &quot;https://ipinfo.io/missingauth&quot;} proxy++在 shell 中启用远程代理，代理服务来自 ssh 连接到这台机器的远程机器（仅适用于局域网） 123456789101112131415161718192021222324$ proxy++proxy has been set to: 192.168.1.66:7890{ &quot;ip&quot;: &quot;103.47.100.220&quot;, &quot;city&quot;: &quot;Sham Shui Po&quot;, &quot;region&quot;: &quot;Sham Shui Po&quot;, &quot;country&quot;: &quot;HK&quot;, &quot;loc&quot;: &quot;22.3302,114.1595&quot;, &quot;org&quot;: &quot;AS38136 Akari Networks&quot;, &quot;timezone&quot;: &quot;Asia/Hong_Kong&quot;, &quot;readme&quot;: &quot;https://ipinfo.io/missingauth&quot;}$ PROXY_PORT=1234 proxy++proxy has been set to: 192.168.1.66:1234{ &quot;ip&quot;: &quot;103.47.100.220&quot;, &quot;city&quot;: &quot;Sham Shui Po&quot;, &quot;region&quot;: &quot;Sham Shui Po&quot;, &quot;country&quot;: &quot;HK&quot;, &quot;loc&quot;: &quot;22.3302,114.1595&quot;, &quot;org&quot;: &quot;AS38136 Akari Networks&quot;, &quot;timezone&quot;: &quot;Asia/Hong_Kong&quot;, &quot;readme&quot;: &quot;https://ipinfo.io/missingauth&quot;} proxy-在 shell 中停用本机上代理 123456789101112$ proxy-proxy has been cleared{ &quot;ip&quot;: &quot;111.3.34.208&quot;, &quot;city&quot;: &quot;Shanghai&quot;, &quot;region&quot;: &quot;Shanghai&quot;, &quot;country&quot;: &quot;CN&quot;, &quot;loc&quot;: &quot;31.2222,121.4581&quot;, &quot;org&quot;: &quot;AS56041 China Mobile communications corporation&quot;, &quot;timezone&quot;: &quot;Asia/Shanghai&quot;, &quot;readme&quot;: &quot;https://ipinfo.io/missingauth&quot;}","link":"/2022/08/02/7.Shell%E8%84%9A%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%9C%A8Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BC%80%E5%90%AF%E4%BB%A3%E7%90%86/"},{"title":"Python在命令行修改Properties配置文件","text":"背景我在平常的工作中，经常需要修改配置文件。配置文件的格式多种多样，有一种配置文件最为常见，就是每一行形如 name=value 格式，例如 Java Properties。在编写这个脚本以前，我常常用 sed 命令来做增删改查，不过我觉得这并不足够方便。 于是我专门写了一个 Python 命令行工具，来批量增删改查上述格式的配置文件，使用时注意要给用户对被处理的配置文件授予必要权限，比如 r 和 w。 代码实现 TIPS 代码的最新版本在 GitHub Gist 中维护https://gist.github.com/ChenyangGao/41e33d761c1e532d5e0b89502bd21414 文件名称为 config_props.py，实现如下： config_props.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280#!/usr/bin/env python3# coding: utf-8assert __name__ == &quot;__main__&quot;, &quot;不能被引入模块&quot;__author__ = &quot;ChenyangGao &lt;https://chenyanggao.github.io/&gt;&quot;__version__ = (0, 1, 1)from argparse import ArgumentParser, RawTextHelpFormatterfrom sys import argvparser = ArgumentParser( description=&quot;增删改查类如 Java Properties 格式的配置文件&quot;, epilog=&quot;😆 友情提示：\\n每项 property 都是单行的，如果要换行，&quot; &quot;请在上一行的末尾加反斜杠（续行符）\\\\&quot;, formatter_class=RawTextHelpFormatter,)subparsers = parser.add_subparsers(dest=&quot;command&quot;, help=&quot;Available commands&quot;)parser_get = subparsers.add_parser( &quot;get&quot;, formatter_class=RawTextHelpFormatter, help=&quot;读取配置：config_props.py get path name ...&quot;,)parser_get.add_argument(&quot;path&quot;, help=&quot;配置文件路径&quot;)parser_get.add_argument( &quot;patterns&quot;, metavar=&quot;pattern&quot;, nargs=&quot;+&quot;, help=&quot;属性名或模式&quot;)parser_get.add_argument( &quot;-t&quot;, &quot;--type&quot;, choices=(&quot;raw&quot;, &quot;wild&quot;, &quot;re&quot;), default=&quot;raw&quot;, help=&quot;&quot;&quot;属性名作为什么模式处理： raw(默认): 视为普通字符串； wild: 视为 unix 通配符模式； re: 视为正则表达式模式。&quot;&quot;&quot;,)parser_get.add_argument( &quot;-s&quot;, &quot;--sign&quot;, default=&quot;=&quot;, help=&quot;属性和值的分界，必须是单个字符，默认为 =&quot;,)parser_get.add_argument( &quot;-e&quot;, &quot;--encoding&quot;, help=&quot;配置文件的编码&quot;,)parser_set = subparsers.add_parser( &quot;set&quot;, formatter_class=RawTextHelpFormatter, help=&quot;更新配置：config_props.py set path name value ...&quot;,)parser_set.add_argument(&quot;path&quot;, help=&quot;配置文件路径&quot;)parser_set.add_argument( &quot;pairs&quot;, metavar=&quot;name value&quot;, nargs=&quot;+&quot;, help=&quot;属性名和属性值的对偶，此参数必须传偶数个&quot;,)parser_set.add_argument( &quot;-s&quot;, &quot;--sign&quot;, default=&quot;=&quot;, help=&quot;属性和值的分界，必须是单个字符，默认为 =&quot;,)parser_set.add_argument( &quot;-e&quot;, &quot;--encoding&quot;, help=&quot;配置文件的编码&quot;,)parser_del = subparsers.add_parser( &quot;del&quot;, formatter_class=RawTextHelpFormatter, help=&quot;删除配置：config_props.py del path name ...&quot;,)parser_del.add_argument(&quot;path&quot;, help=&quot;配置文件路径&quot;)parser_del.add_argument(&quot;patterns&quot;, metavar=&quot;pattern&quot;, nargs=&quot;+&quot;, help=&quot;属性名或模式&quot;)parser_del.add_argument( &quot;-t&quot;, &quot;--type&quot;, choices=(&quot;raw&quot;, &quot;wild&quot;, &quot;re&quot;), default=&quot;raw&quot;, help=&quot;&quot;&quot;属性名作为什么模式处理： raw(默认): 视为普通字符串； wild: 视为 unix 通配符模式； re: 视为正则表达式模式。&quot;&quot;&quot;,)parser_del.add_argument( &quot;-s&quot;, &quot;--sign&quot;, default=&quot;=&quot;, help=&quot;属性和值的分界，必须是单个字符，默认为 =&quot;,)parser_del.add_argument( &quot;-e&quot;, &quot;--encoding&quot;, help=&quot;配置文件的编码&quot;,)parser_uplines = subparsers.add_parser( &quot;uplines&quot;, formatter_class=RawTextHelpFormatter, help=&quot;更新配置：config_props.py uplines path name=value ...&quot;,)parser_uplines.add_argument(&quot;path&quot;, help=&quot;配置文件路径&quot;)parser_uplines.add_argument( &quot;lines&quot;, metavar=&quot;line&quot;, nargs=&quot;+&quot;, help=&quot;&quot;&quot;形如： 1. name: 删除名称是name的属性； 2. name=value: 更新名称是name的属性。&quot;&quot;&quot;,)parser_uplines.add_argument( &quot;-s&quot;, &quot;--sign&quot;, default=&quot;=&quot;, help=&quot;属性和值的分界，必须是单个字符，默认为 =&quot;,)parser_uplines.add_argument( &quot;-e&quot;, &quot;--encoding&quot;, help=&quot;配置文件的编码&quot;,)# TODO: 添加命令 comment，增删改属性上面的注释：config_props.py comment path name=value ...# TODO: 添加命令 merge，合并多个配置文件：config_props.py merge path path2 ...if len(argv) &lt; 2 or argv[1] not in (&quot;get&quot;, &quot;set&quot;, &quot;del&quot;, &quot;uplines&quot;): args = parser.parse_args([&quot;-h&quot;])args = parser.parse_args()sign = args.signassert len(sign) == 1, &quot;属性名和值的分隔符 sign 必须是单字符，比如 =&quot;import reCRE_PROPLINE = re.compile(fr&quot;^[\\t ]*(?!#)(?P&lt;name&gt;[^{sign}\\s]+)[\\t ]*{sign}[\\t ]*(?P&lt;value&gt;.*)&quot;, re.M)class ConfigProps: &quot;&quot;&quot;配置文件管理器 :param path: 配置文件路径 :param encoding: 配置文件的编码，默认为 None，即根据系统给定 &quot;&quot;&quot; def __init__(self, path, encoding=None): self._path = path self.encoding = encoding self.read() def __contains__(self, name): return name in self._map def __len__(self): return len(self._map) def __getitem__(self, name): return self._map[name] @property def path(self): &quot;配置文件路径&quot; return self._path def read(self): &quot;从配置文件中读取配置&quot; try: self._lines = lines = open(self._path, &quot;r&quot;, encoding=self.encoding).readlines() except FileNotFoundError: self._lines = [] self._map = {} return if lines and not lines[-1].endswith(&quot;\\n&quot;): lines[-1] += &quot;\\n&quot; self._map = map_ = {} for lineno, line in enumerate(lines): match = CRE_PROPLINE.search(line) if match is not None: map_[match[&quot;name&quot;]] = [match[&quot;value&quot;], lineno] def write(self): &quot;把最新的配置写入配置文件&quot; open(self._path, &quot;w&quot;, encoding=self.encoding).writelines(self._lines) def search(self, *pats, type=&quot;raw&quot;): &quot;&quot;&quot;生成器，从配置文件中筛选属性名符合任一模式的属性行 :param pats: 属性名的模式 :param type: 以何种模式处理： raw(默认): 视为普通字符串； wild: 视为 unix 通配符模式； re: 视为正则表达式模式。 :return: 迭代器 &quot;&quot;&quot; lines, map_ = self._lines, self._map if not pats: return pats = frozenset(pats) if type == &quot;raw&quot;: predicate = pats.__contains__ elif type == &quot;wild&quot;: from fnmatch import translate predicate = re.compile(&quot;|&quot;.join(map(translate, pats))).fullmatch elif type == &quot;re&quot;: predicate = re.compile(&quot;|&quot;.join(f&quot;(?:{pat})&quot; for pat in pats)).fullmatch else: raise ValueError(f&quot;Unacceptable type value: {type!r}&quot;) for name, (value, lineno) in map_.items(): if predicate(name): yield name, value, lineno def select(self, *pats, type=&quot;raw&quot;): lines = self._lines for _, _, lineno in self.search(*pats, type=type): print(lines[lineno].rstrip(&quot;\\n&quot;)) def delete(self, *pats, type=&quot;raw&quot;): lines, map_ = self._lines, self._map meets = tuple(self.search(*pats, type=type)) t = tuple(map_.values()) for n, (name, value, lineno) in enumerate(meets): line = lines[lineno-n] # 删除 1 行后，这行后面的每 1 行在列表中的索引会 -1 for e in t[lineno+1:]: e[1] -= 1 del map_[name] del lines[lineno-n] print(&quot;Deleted:&quot;, name, &quot;\\n &lt;=&quot;, line.rstrip(&quot;\\n&quot;)) return len(meets) def insert(self, name, value, line=None): lines, map_ = self._lines, self._map if line is None: line = f&quot;{name}={value}\\n&quot; lines.append(line) map_[name] = (value, len(lines)) print(&quot;Inserted:&quot;, name, &quot;\\n =&gt;&quot;, line.rstrip(&quot;\\n&quot;), &quot;&quot;) def update(self, name, value, line=None): lines, map_ = self._lines, self._map if line is None: line = f&quot;{name}={value}\\n&quot; lineno = map_[name][1] map_[name] = value, lineno line_old = lines[lineno] lines[lineno] = line print(&quot;Updated:&quot;, line_old.rstrip(&quot;\\n&quot;), &quot;\\n =&gt;&quot;, line.rstrip(&quot;\\n&quot;)) def upsert(self, name, value, line=None): map_ = self._map if name in map_: self.update(name, value, line) else: self.insert(name, value, line) def update_lines(self, *lines): n = 0 for line in lines: match = CRE_PROPLINE.search(line) if match is None: name = line if name in conf_props: self.delete(name) else: print(&quot;😂 ignored:&quot;, name) continue else: line += &quot;\\n&quot; name, value = match[&quot;name&quot;], match[&quot;value&quot;] self.upsert(name, value, line) n += 1 return ncommand = args.commandpath = args.pathencoding = args.encodingconf_props = ConfigProps(path)if command == &quot;get&quot;: patterns = args.patterns type = args.type conf_props.select(*patterns, type=type)elif command == &quot;set&quot;: pairs = args.pairs names = pairs[::2] values = pairs[1::2] for name, value in zip(names, values): conf_props.upsert(name, value) if names and values: conf_props.write()elif command == &quot;del&quot;: patterns = args.patterns type = args.type if conf_props.delete(*patterns, type=type): conf_props.write()elif command == &quot;uplines&quot;: lines = args.lines if conf_props.update_lines(*lines): conf_props.write()else: raise NotImplementedError 使用说明命令帮助信息如下： 123456789101112131415161718$ python config_props.py -husage: config_props.py [-h] {get,set,del,uplines} ...增删改查类如 Java Properties 格式的配置文件positional arguments: {get,set,del,uplines} Available commands get 读取配置：config_props.py get path name ... set 更新配置：config_props.py set path name value ... del 删除配置：config_props.py del path name ... uplines 更新配置：config_props.py uplines path name=value ...optional arguments: -h, --help show this help message and exit😆 友情提示：每项 property 都是单行的，如果要换行，请在上一行的末尾加反斜杠（续行符）\\ 现在假设待处理的配置文件 example.properties 的内容如下： example.properties1234567891011121314151617## 以下是数据库连接信息# 数据库系统db.dialet = mysql# 主机db.host = localhost# 端口db.port = 3306# 用户名db.username = root# 密码db.password =# 数据库db.database =# 下面是 foo 业务要用到的表foo.table = relation 目前实现了 4 个子命令，示例如下： 1. get 命令命令帮助信息如下： 123456789101112131415161718$ python config_props.py get -husage: config_props.py get [-h] [-t {raw,wild,re}] [-s SIGN] path pattern [pattern ...]positional arguments: path 配置文件路径 pattern 属性名或模式optional arguments: -h, --help show this help message and exit -t {raw,wild,re}, --type {raw,wild,re} 属性名作为什么模式处理： raw(默认): 视为普通字符串； wild: 视为 unix 通配符模式； re: 视为正则表达式模式。 -s SIGN, --sign SIGN 属性和值的分界，必须是单个字符，默认为 = -e ENCODING, --encoding ENCODING 配置文件的编码 使用名称搜索： 123$ python config_props.py get example.properties db.dialet foo.table non.exists.namedb.dialet = mysqlfoo.table = relation 使用 unix 路径通配符模式搜索： 1234567$ python config_props.py get example.properties 'db.*' -t wilddb.dialet = mysqldb.host = localhostdb.port = 3306db.username = rootdb.password =db.database = 使用正则表达式模式搜索： 1234567$ python config_props.py get example.properties 'db\\..*' -t redb.dialet = mysqldb.host = localhostdb.port = 3306db.username = rootdb.password =db.database = 2. set 命令命令帮助信息如下： 123456789101112$ python config_props.py set -husage: config_props.py set [-h] [-s SIGN] path name value [name value ...]positional arguments: path 配置文件路径 name value 属性名和属性值的对偶，此参数必须传偶数个optional arguments: -h, --help show this help message and exit -s SIGN, --sign SIGN 属性和值的分界，必须是单个字符，默认为 = -e ENCODING, --encoding ENCODING 配置文件的编码 执行如下命令： 1234567$ python config_props.py set example.properties db.password 123456 db.database test foo.bar 😂🤣😆😅Updated: db.password = =&gt; db.password=123456Updated: db.database = =&gt; db.database=testInserted: foo.bar =&gt; foo.bar=😂🤣😆😅 配置文件 example.properties 被更新为： example.properties12345678910111213141516171819## 以下是数据库连接信息# 数据库系统db.dialet = mysql# 主机db.host = localhost# 端口db.port = 3306# 用户名db.username = root# 密码db.password=123456# 数据库db.database=test# 下面是 foo 业务要用到的表foo.table = relationfoo.bar=😂🤣😆😅 3. del 命令命令帮助信息如下： 123456789101112131415161718$ python config_props.py del -husage: config_props.py del [-h] [-t {raw,wild,re}] [-s SIGN] path pattern [pattern ...]positional arguments: path 配置文件路径 pattern 属性名或模式optional arguments: -h, --help show this help message and exit -t {raw,wild,re}, --type {raw,wild,re} 属性名作为什么模式处理： raw(默认): 视为普通字符串； wild: 视为 unix 通配符模式； re: 视为正则表达式模式。 -s SIGN, --sign SIGN 属性和值的分界，必须是单个字符，默认为 = -e ENCODING, --encoding ENCODING 配置文件的编码 执行如下命令： 123$ python config_props.py del example.properties foo.bar foo.bazDeleted: foo.bar &lt;= foo.bar=😂🤣😆😅 配置文件 example.properties 被更新为： example.properties123456789101112131415161718## 以下是数据库连接信息# 数据库系统db.dialet = mysql# 主机db.host = localhost# 端口db.port = 3306# 用户名db.username = root# 密码db.password=123456# 数据库db.database=test# 下面是 foo 业务要用到的表foo.table = relation 4. uplines 命令命令帮助信息如下： 1234567891011121314$ python config_props.py uplines -husage: config_props.py uplines [-h] [-s SIGN] path line [line ...]positional arguments: path 配置文件路径 line 形如： 1. name: 删除名称是name的属性； 2. name=value: 更新名称是name的属性。optional arguments: -h, --help show this help message and exit -s SIGN, --sign SIGN 属性和值的分界，必须是单个字符，默认为 = -e ENCODING, --encoding ENCODING 配置文件的编码 执行如下命令： 12345678$ python config_props.py uplines example.properties db.username=test db.password=randomXYZ foo.table foo.barUpdated: db.username = root =&gt; db.username=testUpdated: db.password=123456 =&gt; db.password=randomXYZDeleted: foo.table &lt;= foo.table = relation😂 ignored: foo.bar 配置文件 example.properties 被更新为： example.properties1234567891011121314151617## 以下是数据库连接信息# 数据库系统db.dialet = mysql# 主机db.host = localhost# 端口db.port = 3306# 用户名db.username=test# 密码db.password=randomXYZ# 数据库db.database=test# 下面是 foo 业务要用到的表 未来规划其实我早就完成了，增删改查其他格式配置文件的命令行脚本，诸如： .config,.cnf,.conf,.cfg,.cg,.ini JSON XML YAML TOML 但实现得都比较复杂，并且还用到了一些第三方库，而且在我看来还不够完善。我打算为它们设计并实现一个统一的操作方案，提供类似 XQuery 或 SQL 的增删改查，然后再分享出来，敬请期待后续文章。","link":"/2022/08/26/9.Python%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BF%AE%E6%94%B9Properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"title":"Python函数作为命令行使用","text":"背景我最近了解了一个快速构建命令行的工具 typer，受到了一些启发。它可以把一组带有类型注解的 Python 函数，快速地转换成命令行工具。我尝试只用 Python 的内建包，不引入第三方依赖，也实现一个类似的命令行快速构建工具。代码会持续更新，之后会加入更强的功能。 代码实现 TIPS 代码的最新版本在 GitHub Gist 中维护https://gist.github.com/ChenyangGao/da8b5dc4370425edaef87237cd27fd15 注意：使用下面的代码，请用 Python 3.8 或者以上版本。 文件名称是 func_cmdline.py，Python 实现代码如下： func_cmdline.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#!/usr/bin/env python3# coding: utf-8__author__ = &quot;ChenyangGao &lt;https://chenyanggao.github.io/&gt;&quot;__version__ = (0, 1, 1)__all__ = [&quot;func_cmdline&quot;]# Inspired by:# - https://pypi.org/project/typer/import inspectfrom argparse import ArgumentParser, Namespace, RawDescriptionHelpFormatterfrom functools import partialfrom textwrap import dedent, indentfrom typing import cast, Callable, Optionaldef func_cmdline( fn: Optional[Callable] = None, /, parser: Optional[ArgumentParser] = None, parse_map: dict[type, Callable] = {}, helpinfo_map: dict[str, str] = {}, ) -&gt; Callable: &quot;&quot;&quot;装饰器让一个函数，可以作为命令行使用 :param fn: 被装饰的函数 :param parser: 命令行解析器对象 :param parse_map: 不同类型的解析函数的映射， 字符串通过相应的解析函数来转换成对应对象， 如果没有相应的解析函数，则尝试用对象本身 （它的构造器） :param helpinfo_map: 不同参数的帮助说明， 用于命令行的帮助信息 :param: 返函数`fn`本身，只是它身上绑定了几个属性 .parser 字段，使用的命令行解析器对象 .parse() 方法，解析命令行参数 .run() 方法，解析命令行参数并运行函数`fn`， 返回函数`fn`的执行结果 :return: 被装饰函数本身，添加了几个属性 &quot;&quot;&quot; if fn is None: return partial( func_cmdline, parser=parser, parse_map=parse_map, helpinfo_map=helpinfo_map, ) fn = cast(Callable, fn) params = inspect.signature(fn).parameters if parser is None: parser = ArgumentParser( formatter_class=RawDescriptionHelpFormatter) parser = cast(ArgumentParser, parser) if parser.epilog is None: parser.epilog = &quot;&quot; if fn.__doc__ is not None: parser.epilog += &quot;documentation:\\n&quot; + \\ indent(fn.__doc__, &quot; &quot;) parser.epilog += &quot;\\n\\nsource code:\\n&quot; + \\ indent(dedent(inspect.getsource(fn)), &quot; &quot;) abbrs: dict[str, int] = {} for name, param in params.items(): kargs: dict = {&quot;dest&quot;: name, &quot;help&quot;: helpinfo_map.get(name)} kind = param.kind if kind is inspect._ParameterKind.VAR_POSITIONAL: kargs[&quot;required&quot;] = False kargs[&quot;nargs&quot;] = &quot;*&quot; kargs[&quot;default&quot;] = [] elif kind is inspect._ParameterKind.VAR_KEYWORD: continue default = param.default if default is inspect._empty: kargs.setdefault(&quot;required&quot;, True) else: kargs[&quot;default&quot;] = default anno = param.annotation if anno is not inspect._empty: if anno is bool: kargs[&quot;required&quot;] = False if &quot;default&quot; in kargs: if kargs[&quot;default&quot;]: kargs[&quot;action&quot;] = &quot;store_false&quot; else: kargs[&quot;action&quot;] = &quot;store_true&quot; else: kargs[&quot;action&quot;] = &quot;store_true&quot; elif anno is list: kargs[&quot;nargs&quot;] = &quot;*&quot; elif getattr(anno, &quot;__origin__&quot;, None) is list and len(anno.__args__) == 1: kargs[&quot;nargs&quot;] = &quot;*&quot; kargs[&quot;type&quot;] = parse_map.get(anno.__args__[0], anno.__args__[0]) else: kargs[&quot;type&quot;] = parse_map.get(anno, anno) names = [] first_letter = name[0] n = abbrs.setdefault(first_letter, 0) if n == 0: abbr = first_letter else: abbr = f&quot;{first_letter}{n}&quot; abbrs[first_letter] += 1 names.append(f&quot;-{abbr}&quot;) names.append(f&quot;--{name}&quot;) if &quot;_&quot; in name: names.append(f&quot;--{name.replace('_', '-')}&quot;) parser.add_argument(*names, **kargs) def parse(argv: Optional[list[str]] = None) -&gt; Namespace: nonlocal parser parser = cast(ArgumentParser, parser) return parser.parse_args(argv) def run(argv: Optional[list[str]] = None): &quot;解析命令行参数，默认使用&quot; nonlocal fn, parser fn = cast(Callable, fn) parser = cast(ArgumentParser, parser) args = parser.parse_args(argv).__dict__ pargs = [] kargs = {} for name, param in params.items(): kind = param.kind if name in args: if kind.value &lt; 2: pargs.append(args[name]) elif kind.value == 2: pargs.extend(args[name]) else: kargs[name] = args[name] return fn(*pargs, **kargs) setattr(fn, &quot;parser&quot;, parser) setattr(fn, &quot;parse&quot;, parse) setattr(fn, &quot;run&quot;, run) return fnif __name__ == &quot;__main__&quot;: from datetime import datetime @func_cmdline( parse_map={ datetime: lambda s: datetime.strptime(s, &quot;%Y-%m-%d %H:%M:%S&quot;), }, helpinfo_map=dict( a=&quot;参数a&quot;, b=&quot;参数b&quot;, c=&quot;参数c&quot;, d=&quot;参数d&quot;, e=&quot;参数e&quot;, ) ) def foo( a: int, /, b: bool = False, *c: float, d: list[datetime], e: complex = 4, ): &quot;Example for function as command line.&quot; print(locals()) foo.run() 使用说明模块 func_cmdline.py 自带了一个实例： 12345678910111213141516171819from datetime import datetime@func_cmdline( parse_map={ datetime: lambda s: datetime.strptime(s, &quot;%Y-%m-%d %H:%M:%S&quot;), }, helpinfo_map=dict( a=&quot;参数a&quot;, b=&quot;参数b&quot;, c=&quot;参数c&quot;, d=&quot;参数d&quot;, e=&quot;参数e&quot;, ))def foo( a: int, /, b: bool = True, *c: float, d: list[datetime], e: complex = 1j, ): &quot;Example for function as command line.&quot; print(locals())foo.run() 直接运行模块，输出如下： 1234567891011121314151617181920212223242526272829303132$ python func_cmdline.py -husage: func_cmdline.py [-h] -a A [-b] [-c [C ...]] -d [D ...] [-e E]optional arguments: -h, --help show this help message and exit -a A, --a A 参数a -b, --b 参数b -c [C ...], --c [C ...] 参数c -d [D ...], --d [D ...] 参数d -e E, --e E 参数edocumentation: Example for function as command line.source code: @func_cmdline( parse_map={ datetime: lambda s: datetime.strptime(s, &quot;%Y-%m-%d %H:%M:%S&quot;), }, helpinfo_map=dict( a=&quot;参数a&quot;, b=&quot;参数b&quot;, c=&quot;参数c&quot;, d=&quot;参数d&quot;, e=&quot;参数e&quot;, ) ) def foo( a: int, /, b: bool = False, *c: float, d: list[datetime], e: complex = 1j, ): &quot;Example for function as command line.&quot; print(locals()) 随便传入一些必需的参数，不传可选参数： 12$ python func_cmdline.py --a 1 --d '2021-01-01 00:00:00' '2021-02-01 00:00:00' '2021-03-01 00:00:00'{'a': 1, 'b': False, 'd': [datetime.datetime(2021, 1, 1, 0, 0), datetime.datetime(2021, 2, 1, 0, 0), datetime.datetime(2021, 3, 1, 0, 0)], 'e': 1j, 'c': ()} 对各个参数随便传入一些可用的值： 12$ python func_cmdline.py --a 1 -b -c 2 3 4 --d '2021-01-01 00:00:00' '2021-02-01 00:00:00' '2021-03-01 00:00:00' -e '5+6j'{'a': 1, 'b': True, 'd': [datetime.datetime(2021, 1, 1, 0, 0), datetime.datetime(2021, 2, 1, 0, 0), datetime.datetime(2021, 3, 1, 0, 0)], 'e': (5+6j), 'c': (2.0, 3.0, 4.0)}","link":"/2022/08/13/8.Python%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BD%BF%E7%94%A8/"},{"title":"掩码（Python实现）","text":"关于掩码什么是标志flag在掩码的语境下，标志flag，是只有1位的掩码，取值范围$range(\\mathrm{flag})$满足：$$range(\\mathrm{flag}) = {0, 1}$$。 flag可以是一个单纯的取值范围为${0,1}$的二值的状态量，也可以是相对于另一个取值范围是${s_1, s_2}$的二值的状态量state，所建立一一映射$$\\mathrm{flag}: {s_1, s_2} \\leftrightarrow {0,1}$$。 Note 更一般而且常见的，标志flag是一个离散的状态量，取值范围是自然数集$\\N$的子集。它可以是单纯的状态量，也可以是：设存在一个状态量state，它的取值范围$range(\\mathrm{state})$是离散的，flag是$range(\\mathrm{state})$到自然数集$\\N$的映射$$\\mathrm{flag}: range(\\mathrm{state}) \\to \\N$$。也即，使用不同的自然数来分别枚举和指代状态量state的各个状态值。 什么是掩码mask掩码mask，是一个二进制的位模式，取值范围$range(\\mathrm{mask})$满足：$$range(\\mathrm{mask}) = {0, 1}^n, n \\in \\N$$。 mask是一个状态量，或者状态映射：给定状态向量state，是一组二值的状态量${\\mathrm{state}i \\big| 0 &lt; i \\le n, n \\in \\N}$的序列，分别有取值范围$range(\\mathrm{state}i)={s{i, 1}, s{i, 2}}$，mask是相对于state，所建立一一映射$$\\mathrm{mask}: \\underset{i=1}{\\overset{n}{\\times}}{s_{i, 1}, s_{i, 2}} \\leftrightarrow {0,1}^n$$。 Note 标志flag的值域是标量scalar，掩码mask的值域是向量vector，两者都是状态量或者状态映射。可以认为，mask是建立在${0,1}^n,n \\in \\N$上的线性空间，给定它的一组基${\\bold{u}_i \\in {0,1}^n \\big| 0 &lt; i \\le n;\\forall 0 &lt; i, j \\le n,\\bold{u}_i[j] = 1 \\iff i = j}$，也即分别有$\\bold{u}_i$对应于mask的第$i$位。令标志$\\mathrm{flag}_i$对应于$\\mathrm{mask}$的第$i$位的值，即有$\\mathrm{flag}i = \\mathrm{mask}[i]$且有线性组合$$\\mathrm{mask} = \\sum{i=1}^n \\mathrm{flag}_i \\cdot \\bold{u}_i$$。总而言之，mask的每一位分别对应一个flag，mask是多个占据不同位的flag的线性组合，因此mask是一个状态向量或者组合状态映射。 实现：标志Flag123456789101112131415161718192021222324class Flag: def __init__(self): self._value = 0 @property def flag(self) -&gt; int: return self._value def set(self): 'set the flag to 1' self._value = 1 def clear(self): 'set the flag to 0' self._value = 0 def reverse(self): 'reverse/invert the flag, 0 to 1, 1 to 0' self._value ^= 1 def isset(self) -&gt; bool: 'Is flag = 1?' return self._value is 1 实现：掩码MaskNote 因为在Python中，int是不可变类型，操作的结果往往会产生新的int对象，这是低效的。建议使用C扩展或者某些可改动内存的结构，至少保证位操作可以复用原来的内存区域。 mask.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120from typing import TypeVar, Generic, UnionT = TypeVar('T')class MaskOpMixin(Generic[T]): def __eq__(self, o: Union[int, T]) -&gt; bool: if isinstance(o, type(self)): o = o._value return self._value == o def __invert__(self): return type(self)(~self._value) def __and__(self, o: Union[int, T]) -&gt; T: cls = type(self) if isinstance(o, cls): o = o._value return cls(self._value &amp; o) def __or__(self, o: Union[int, T]) -&gt; T: cls = type(self) if isinstance(o, cls): o = o._value return cls(self._value | o) def __xor__(self, o: Union[int, T]) -&gt; T: cls = type(self) if isinstance(o, cls): o = o._value return cls(self._value ^ o) __rand__ = __and__ __ror__ = __or__ __rxor__ = __xor__ def __iand__(self, o: Union[int, T]) -&gt; T: if isinstance(o, type(self)): o = o._value self._value &amp;= o return self def __ior__(self, o: Union[int, T]) -&gt; T: if isinstance(o, type(self)): o = o._value self._value |= o return self def __ixor__(self, o: Union[int, T]) -&gt; T: if isinstance(o, type(self)): o = o._value self._value ^= o return self def __sub__(self, o: Union[int, T]) -&gt; T: cls = type(self) if isinstance(o, cls): o = o._value # 🤔 l &amp; ~r == (l | r) ^ r return cls(self._value &amp; ~o) def __isub__(self, o: Union[int, T]) -&gt; T: if isinstance(o, type(self)): o = o._value self._value &amp;= ~o return selfclass MaskBase: def __init__(self, mask: int = 0) -&gt; None: self._value = mask @property def mask(self) -&gt; int: return self._value @property def binmask(self) -&gt; str: return bin(self._value) def __repr__(self) -&gt; str: return f'{type(self).__name__}({bin(self._value)})' def set(self, m: int) -&gt; None: 'set mask by offset m' self._value |= 1 &lt;&lt; m def clear(self, m: int) -&gt; None: 'clear mask by offset m' self._value &amp;= ~(1 &lt;&lt; m) def reverse(self, m: Union[int, MaskBase]) -&gt; None: 'reverse/invert mask by offset m' self._value ^= 1 &lt;&lt; m def test(self, m: int) -&gt; bool: 'test mask by offset m' return bool(self._value &amp; 1 &lt;&lt; m)class Mask(MaskBase, MaskOpMixin[MaskBase]): def set(self, m: Union[int, MaskBase]) -&gt; None: 'set mask by mask m' self |= m def clear(self, m: Union[int, MaskBase]) -&gt; None: 'clear mask by mask m' self -= m def reverse(self, m: Union[int, MaskBase]) -&gt; None: 'reverse/invert mask by mask m' self ^= m def test(self, m: Union[int, MaskBase]) -&gt; bool: 'clear mask by mask m' return self &amp; m == m 测试结果如下： 1234567891011121314151617&gt;&gt;&gt; from mask import *&gt;&gt;&gt; EVENT0 = 1 &lt;&lt; 0&gt;&gt;&gt; EVENT1 = 1 &lt;&lt; 1&gt;&gt;&gt; EVENT2 = 1 &lt;&lt; 2&gt;&gt;&gt; EVENT3 = 1 &lt;&lt; 3&gt;&gt;&gt; m = Mask(EVENT1)&gt;&gt;&gt; m.set(EVENT0 | EVENT3)&gt;&gt;&gt; mMask(0b1011)&gt;&gt;&gt; m.test(EVENT0 | EVENT1)True&gt;&gt;&gt; m.clear(EVENT0 | EVENT1)&gt;&gt;&gt; mMask(0b1000)&gt;&gt;&gt; m.reverse((1 &lt;&lt; 4) - 1)&gt;&gt;&gt; mMask(0b111)","link":"/2019/07/04/4.%E6%8E%A9%E7%A0%81%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/"}],"tags":[{"name":"博弈论","slug":"博弈论","link":"/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Script","slug":"Script","link":"/tags/Script/"},{"name":"Module","slug":"Module","link":"/tags/Module/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"}],"categories":[{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"脚本工具","slug":"脚本工具","link":"/categories/%E8%84%9A%E6%9C%AC%E5%B7%A5%E5%85%B7/"},{"name":"通用模块","slug":"通用模块","link":"/categories/%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"name":"经济学","slug":"数学/经济学","link":"/categories/%E6%95%B0%E5%AD%A6/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"},{"name":"简单脚本","slug":"简单脚本","link":"/categories/%E7%AE%80%E5%8D%95%E8%84%9A%E6%9C%AC/"},{"name":"编程思想","slug":"编程思想","link":"/categories/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"}],"pages":[]}